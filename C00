local colours = {

    red = Color3.fromRGB(255, 49, 97),

    red_dark = Color3.fromRGB(208, 40, 79)

}

local library = {}

function library:createwindow()

	local thething = Instance.new("ScreenGui")	thething.ResetOnSpawn = false

	thething.Parent = game.CoreGui

	local mainframe = Instance.new("Frame")

	local UICorner = Instance.new("UICorner")

	local Frame = Instance.new("Frame")

	local Frame_2 = Instance.new("Frame")

	local UICorner_2 = Instance.new("UICorner")

	local Frame_3 = Instance.new("Frame")

	local Frame_4 = Instance.new("Frame")

	local UIGridLayout = Instance.new("UIGridLayout")

    local menu = Instance.new("Frame")

    local UICorner3 = Instance.new("UICorner")

    local holder = Instance.new("Frame")

    local UIListLayoutt = Instance.new("UIListLayout")

    local seperator = Instance.new("Frame")

    local menubutton = Instance.new("ImageButton")

    local scrolling = Instance.new("ScrollingFrame")

	--local UICorner_4 = Instance.new("UICorner")

	thething.Name = "thething"

	thething.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

	mainframe.Name = "mainframe"

	mainframe.Parent = thething

	mainframe.BackgroundColor3 = Color3.fromRGB(33, 33, 33)

	mainframe.BorderSizePixel = 0

	mainframe.ClipsDescendants = true

	mainframe.Position = UDim2.new(0.258023918, 0, 0.358672351, 0)

	mainframe.Size = UDim2.new(0, 570, 0, 228)

    local UIS = game:GetService("UserInputService")

	function dragifyyy(Frame)

		dragTogglee = nil

		dragInputt = nil

		dragStart = nil

		function updateInputt(input)

			local Delta = input.Position - dragStart

			local Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + Delta.X, startPos.Y.Scale, startPos.Y.Offset + Delta.Y)

			--Frame.Position = Position

			game:GetService("TweenService"):Create(Frame, TweenInfo.new(0.09), {Position = Position}):Play()

		end

		Frame.InputBegan:Connect(function(input)

			if (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch) and UIS:GetFocusedTextBox() == nil then

				dragTogglee = true

				dragStart = input.Position

				startPos = Frame.Position

				input.Changed:Connect(function()

					if input.UserInputState == Enum.UserInputState.End then

						dragTogglee = false

					end

				end)

			end

		end)

		Frame.InputChanged:Connect(function(input)

			if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then

				dragInputt = input

			end

		end)

		game:GetService("UserInputService").InputChanged:Connect(function(input)

			if input == dragInputt and dragTogglee then

				updateInputt(input)

			end

		end)

	end

	dragifyyy(mainframe)

	UICorner.CornerRadius = UDim.new(0, 4)

	UICorner.Parent = mainframe

	scrolling.Parent = mainframe

	scrolling.Active = true

	scrolling.BackgroundColor3 = Color3.fromRGB(255, 255, 255)

	scrolling.BackgroundTransparency = 1.000

	scrolling.BorderSizePixel = 0

	scrolling.ClipsDescendants = false

	scrolling.Position = UDim2.new(0, 0, -0.0181818176, 0)

	scrolling.Size = UDim2.new(0, 563, 0, 168)

	scrolling.ScrollBarThickness = 0

	Frame.Parent = mainframe

	Frame.BackgroundColor3 = colours.red

	Frame.BorderSizePixel = 0

	Frame.Size = UDim2.new(0, 570, 0, 39)

	Frame.ZIndex = 3

	Frame_2.Parent = Frame

	Frame_2.BackgroundColor3 = colours.red

	Frame_2.BorderSizePixel = 0

	Frame_2.Position = UDim2.new(0, 0, 0.846153855, 0)

	Frame_2.Size = UDim2.new(0, 570, 0, 6)

	UICorner_2.CornerRadius = UDim.new(0, 4)

	UICorner_2.Parent = Frame

	Frame_3.Parent = Frame

	Frame_3.BackgroundColor3 = colours.red_dark

	Frame_3.BorderSizePixel = 0

	Frame_3.Position = UDim2.new(0, 0, 1, 0)

	Frame_3.Size = UDim2.new(0, 570, 0, 12)

	Frame_4.Parent = scrolling

	Frame_4.BackgroundColor3 = Color3.fromRGB(255, 255, 255)

	Frame_4.BackgroundTransparency = 1.000

	Frame_4.Position = UDim2.new(0, 6,  0, 65)

	Frame_4.Size = UDim2.new(0, 569, 0, 165)

	UIGridLayout.Parent = Frame_4

	UIGridLayout.SortOrder = Enum.SortOrder.LayoutOrder

	UIGridLayout.CellPadding = UDim2.new(0, 7, 0, 9)

	UIGridLayout.CellSize = UDim2.new(0, 106, 0, 27)

    menu.Name = "menu"

    menu.Parent = mainframe

    menu.BackgroundColor3 = Color3.fromRGB(31, 31, 31)

    menu.BorderSizePixel = 0

    menu.Position = UDim2.new(-0.224561408, 0, 0, 0)

    menu.Size = UDim2.new(0, 128, 0, 228)

    menu.ZIndex = 5

    UICorner3.CornerRadius = UDim.new(0, 4)

    UICorner3.Name = "UICorner3"

    UICorner3.Parent = menu

    holder.Name = "holder"

    holder.Parent = menu

    holder.BackgroundColor3 = Color3.fromRGB(255, 255, 255)

    holder.BackgroundTransparency = 1.000

    holder.Position = UDim2.new(0, 0, 0.0614035092, 0)

    holder.Size = UDim2.new(0, 128, 0, 206)

    UIListLayoutt.Name = "UIListLayoutt"

    UIListLayoutt.Parent = holder

    UIListLayoutt.HorizontalAlignment = Enum.HorizontalAlignment.Center

    UIListLayoutt.SortOrder = Enum.SortOrder.LayoutOrder

    UIListLayoutt.Padding = UDim.new(0, 11)

    seperator.Name = "seperator"

    seperator.Parent = menu

    seperator.BackgroundColor3 = Color3.fromRGB(31, 31, 31)

    seperator.BorderSizePixel = 0

    seperator.Position = UDim2.new(0.930524826, 0, 0, 0)

    seperator.Size = UDim2.new(0, 9, 0, 228)

    menubutton.Name = "menubutton"

    menubutton.Parent = Frame

    menubutton.BackgroundTransparency = 1.000

    menubutton.Position = UDim2.new(0.0105263162, 0, 0.179487184, 0)

    menubutton.Size = UDim2.new(0, 25, 0, 25)

    menubutton.ZIndex = 2

    menubutton.Image = "rbxassetid://3926305904"

    menubutton.ImageRectOffset = Vector2.new(604, 684)

    menubutton.ImageRectSize = Vector2.new(36, 36)

    local menuopen = false

    menubutton.MouseButton1Down:Connect(function()

        if menuopen == false then

            menubutton:TweenPosition(UDim2.new(0.24, 0, 0.179, 0), 'Out', 'Quad', 0.5)

            menu:TweenPosition(UDim2.new(0, 0, 0, 0), 'Out', 'Quad', 0.5)

            menuopen = true

        else

            menubutton:TweenPosition(UDim2.new(0.011, 0, 0.179, 0), 'Out', 'Quad', 0.5)

            menu:TweenPosition(UDim2.new(-0.225, 0, 0, 0), 'Out', 'Quad', 0.5)

            menuopen = false

        end

    end)

	--UICorner_4.CornerRadius = UDim.new(0, 4)

	--UICorner_4.Parent = TextButton

	local coollibrary = {}

	function coollibrary:createbutton(text, callback)

		local callback = callback or function() end

		local TextButton = Instance.new("TextButton")

        local Frame_5 = Instance.new("Frame")

        local UICorner_3 = Instance.new("UICorner")

		local UICorner_4 = Instance.new("UICorner")

        Frame_5.Parent = Frame_4

        Frame_5.BackgroundColor3 = colours.red_dark

        Frame_5.BorderSizePixel = 0

        Frame_5.Position = UDim2.new(0.0642857179, 0, 0.87766856, 0)

        Frame_5.Size = UDim2.new(0, 106, 0, 27)

		TextButton.Parent = Frame_5

		TextButton.BackgroundColor3 = colours.red

		TextButton.BorderSizePixel = 0

		TextButton.Position = UDim2.new(0, 0, -0.222222224, 0)

		TextButton.Size = UDim2.new(0, 106, 0, 27)

		TextButton.AutoButtonColor = false

		TextButton.Font = Enum.Font.SourceSansLight

		TextButton.Text = text

		TextButton.TextColor3 = Color3.fromRGB(255, 255, 255)

		TextButton.TextSize = 14.000

		TextButton.TextWrapped = true

		UICorner_4.CornerRadius = UDim.new(0, 4)

		UICorner_4.Parent = TextButton

        UICorner_3.CornerRadius = UDim.new(0, 4)

	    UICorner_3.Parent = Frame_5

	    TextButton.MouseButton1Down:Connect(function()

	    	TextButton:TweenPosition(UDim2.new(0, 0, 0, 0), 'Out', 'Quad', 0.2)

	    	pcall(callback)

	    	wait(0.2)

	    	TextButton:TweenPosition(UDim2.new(0, 0, -0.222, 0), 'Out', 'Quad', 0.2)

	    end)

	end

	function coollibrary:createtext(text, textsize)

		function lol()

			local TextButton = Instance.new("TextButton")

			TextButton.Parent = Frame_4

			TextButton.BackgroundColor3 = Color3.fromRGB(255,255,255)

			TextButton.BackgroundTransparency = 1

			TextButton.TextTransparency = 1

			TextButton.BorderSizePixel = 0

			TextButton.Position = UDim2.new(0, 0, -0.222222224, 0)

			TextButton.Size = UDim2.new(0, 106, 0, 27)

			TextButton.AutoButtonColor = false

		end

		local Frame = Instance.new("Frame")

		local TextLabel = Instance.new("TextLabel")

		Frame.Parent = Frame_4

		Frame.BackgroundColor3 = Color3.fromRGB(255, 255, 255)

		Frame.BackgroundTransparency = 1.000

		Frame.Size = UDim2.new(0, 100, 0, 100)

		TextLabel.Parent = Frame

		TextLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)

		TextLabel.BackgroundTransparency = 1.000

        if textsize == 18 then

            TextLabel.Position = UDim2.new(1.28301883, 0, -0.5, 0)

            TextLabel.Size = UDim2.new(0, 286, 0, 18)

            TextLabel.Font = Enum.Font.SourceSansLight

            TextLabel.Text = text

            TextLabel.TextColor3 = Color3.fromRGB(255, 255, 255)

            TextLabel.TextSize = textsize

            lol()

            lol()

            lol()

            lol()

        else

            TextLabel.Position = UDim2.new(1.28301883, 0, 0, 0)

            TextLabel.Size = UDim2.new(0, 286, 0, 18)

            TextLabel.Font = Enum.Font.SourceSansLight

            TextLabel.Text = text

            TextLabel.TextColor3 = Color3.fromRGB(255, 255, 255)

            TextLabel.TextSize = textsize

            lol()

            lol()

            lol()

            lol()

        end

		

	end

	function coollibrary:createtoggle(text, callback)

		local actions = {}

		text = text or "toggle"

		callback = callback or function() end

		local enabled = false

		local TextLabel = Instance.new("TextLabel")

		local Frame = Instance.new("Frame")

		local UICorner = Instance.new("UICorner")

		local TextButton = Instance.new("TextButton")

		local UICorner_2 = Instance.new("UICorner")

		--Properties:

		TextLabel.Parent = Frame_4

		TextLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)

		TextLabel.BackgroundTransparency = 1.000

		TextLabel.Position = UDim2.new(0.198594019, 0, -0.0363636352, 0)

		TextLabel.Size = UDim2.new(0, 106, 0, 33)

		TextLabel.Font = Enum.Font.SourceSansLight

        TextLabel.TextXAlignment = Enum.TextXAlignment.Left

		TextLabel.Text = text

		TextLabel.TextColor3 = Color3.fromRGB(255, 255, 255)

		TextLabel.TextSize = 17.000

		Frame.Parent = TextLabel

		Frame.BackgroundColor3 = colours.red_dark

		Frame.BorderSizePixel = 0

		Frame.Position = UDim2.new(0.699, 0, 0, 0)

		Frame.Size = UDim2.new(0, 31, 0, 27)

		UICorner.CornerRadius = UDim.new(0, 4)

		UICorner.Parent = Frame

		TextButton.Parent = Frame

		TextButton.BackgroundColor3 = colours.red

		TextButton.BorderSizePixel = 0

		TextButton.Position = UDim2.new(0, 0, -0.222222224, 0)

		TextButton.Size = UDim2.new(0, 31, 0, 27)

		TextButton.AutoButtonColor = false

		TextButton.Font = Enum.Font.SourceSansLight

		TextButton.Text = ""

		TextButton.TextColor3 = Color3.fromRGB(255, 255, 255)

		TextButton.TextSize = 14.000

		TextButton.TextWrapped = true

		UICorner_2.CornerRadius = UDim.new(0, 4)

		UICorner_2.Parent = TextButton

		local function fire()

			enabled = not enabled

			TextButton:TweenPosition(UDim2.new(0, 0, 0, 0), 'Out', 'Quad', 0.2)

			game:GetService("TweenService"):Create(TextButton, TweenInfo.new(0.2), {

				['BackgroundColor3'] = enabled and Color3.fromRGB(126, 255, 137) or Color3.fromRGB(255, 49, 97)

			}):Play();

			TextButton:TweenPosition(UDim2.new(0, 0, 0, 0), 'Out', 'Quad', 0.2)

			pcall(callback, enabled)

			game:GetService("TweenService"):Create(Frame, TweenInfo.new(0.2), {

				['BackgroundColor3'] = enabled and Color3.fromRGB(96, 195, 104) or Color3.fromRGB(208, 40, 79)

			}):Play();

			wait(0.2)

			TextButton:TweenPosition(UDim2.new(0, 0, -0.222, 0), 'Out', 'Quad', 0.2)

		end	

		TextButton.MouseButton1Down:Connect(fire)

		function actions:Set(arg)

			TextButton:TweenPosition(UDim2.new(0, 0, 0, 0), 'Out', 'Quad', 0.2)

			game:GetService("TweenService"):Create(TextButton, TweenInfo.new(0.2), {

				['BackgroundColor3'] = enabled and Color3.fromRGB(126, 255, 137) or Color3.fromRGB(255, 49, 97)

			}):Play();

			TextButton:TweenPosition(UDim2.new(0, 0, 0, 0), 'Out', 'Quad', 0.2)

			pcall(callback, enabled)

			game:GetService("TweenService"):Create(Frame, TweenInfo.new(0.2), {

				['BackgroundColor3'] = enabled and Color3.fromRGB(96, 195, 104) or Color3.fromRGB(208, 40, 79)

			}):Play();

			wait(0.2)

			TextButton:TweenPosition(UDim2.new(0, 0, -0.222, 0), 'Out', 'Quad', 0.2)

		end

	end

    function coollibrary:createmenu(text, callback)

        local callback = callback or function() end

        local button = Instance.new("Frame")

        local UICorner2 = Instance.new("UICorner")

        local textbuttonbro = Instance.new("TextButton")

        local UICornerrr1 = Instance.new("UICorner")

        button.Name = "button"

        button.Parent = holder

        button.BackgroundColor3 = Color3.fromRGB(35, 35, 35)

        button.BorderSizePixel = 0

        button.Position = UDim2.new(0.055524826, 0, 0.0795464292, 0)

        button.Size = UDim2.new(0, 112, 0, 27)

        UICorner2.CornerRadius = UDim.new(0, 4)

        UICorner2.Name = "UICorner2"

        UICorner2.Parent = button

        textbuttonbro.Name = "textbuttonbro"

        textbuttonbro.Parent = button

        textbuttonbro.BackgroundColor3 = Color3.fromRGB(39, 39, 39)

        textbuttonbro.BorderSizePixel = 0

        textbuttonbro.Position = UDim2.new(0, 0, -0.222222224, 0)

        textbuttonbro.Size = UDim2.new(0, 112, 0, 27)

        textbuttonbro.AutoButtonColor = false

        textbuttonbro.Font = Enum.Font.SourceSansLight

        textbuttonbro.Text = text

        textbuttonbro.TextColor3 = Color3.fromRGB(255, 255, 255)

        textbuttonbro.TextSize = 14.000

        textbuttonbro.TextWrapped = true

        UICornerrr1.CornerRadius = UDim.new(0, 4)

        UICornerrr1.Name = "UICornerrr1"

        UICornerrr1.Parent = textbuttonbro

        textbuttonbro.MouseButton1Down:Connect(function()

	    	textbuttonbro:TweenPosition(UDim2.new(0, 0, 0, 0), 'Out', 'Quad', 0.2)

	    	pcall(callback)

	    	wait(0.2)

	    	textbuttonbro:TweenPosition(UDim2.new(0, 0, -0.222, 0), 'Out', 'Quad', 0.2)

	    end)

    end

	return coollibrary

end

local main = library:createwindow()

main:createtext("Scripts", 40) 

main:createbutton("R6", function() -- add a button

HumanDied = false

local CountSCIFIMOVIELOL = 1

function SCIFIMOVIELOL(Part0,Part1,Position,Angle)

	local AlignPos = Instance.new('AlignPosition', Part1); AlignPos.Name = "AliP_"..CountSCIFIMOVIELOL

	AlignPos.ApplyAtCenterOfMass = true;

	AlignPos.MaxForce = 5772000--67752;

	AlignPos.MaxVelocity = math.huge/9e110;

	AlignPos.ReactionForceEnabled = false;

	AlignPos.Responsiveness = 200;

	AlignPos.RigidityEnabled = false;

	local AlignOri = Instance.new('AlignOrientation', Part1); AlignOri.Name = "AliO_"..CountSCIFIMOVIELOL

	AlignOri.MaxAngularVelocity = math.huge/9e110;

	AlignOri.MaxTorque = 5772000

	AlignOri.PrimaryAxisOnly = false;

	AlignOri.ReactionTorqueEnabled = false;

	AlignOri.Responsiveness = 200;

	AlignOri.RigidityEnabled = false;

	local AttachmentA=Instance.new('Attachment',Part1); AttachmentA.Name = "AthP_"..CountSCIFIMOVIELOL

	local AttachmentB=Instance.new('Attachment',Part0); AttachmentB.Name = "AthP_"..CountSCIFIMOVIELOL

	local AttachmentC=Instance.new('Attachment',Part1); AttachmentC.Name = "AthO_"..CountSCIFIMOVIELOL

	local AttachmentD=Instance.new('Attachment',Part0); AttachmentD.Name = "AthO_"..CountSCIFIMOVIELOL

	AttachmentC.Orientation = Angle or Vector3.new(0,0,0)

	AttachmentA.Position = Position or Vector3.new(0,0,0)

	AlignPos.Attachment1 = AttachmentA;

	AlignPos.Attachment0 = AttachmentB;

	AlignOri.Attachment1 = AttachmentC;

	AlignOri.Attachment0 = AttachmentD;

	CountSCIFIMOVIELOL = CountSCIFIMOVIELOL + 1

	return {AlignPos,AttachmentA,AttachmentB,AlignOri,AttachmentC,AttachmentD}

end

if _G.netted ~= true then

	_G.netted = true

	coroutine.wrap(function()

		settings().Physics.PhysicsEnvironmentalThrottle = Enum.EnviromentalPhysicsThrottle.Disabled

		settings().Physics.ThrottleAdjustTime = math.huge*math.huge

		settings().Physics.AllowSleep = false

		game:GetService("RunService").RenderStepped:Connect(function()

			game:FindFirstChildOfClass("Players").LocalPlayer.MaximumSimulationRadius=math.pow(math.huge,math.huge)

			sethiddenproperty(game:FindFirstChildOfClass("Players").LocalPlayer,"SimulationRadius",math.huge*math.huge)

		end)

	end)()

end

game:FindFirstChildOfClass("Players").LocalPlayer["Character"].Archivable = true

local hatnameclone = {}

for _,v in next, game:FindFirstChildOfClass("Players").LocalPlayer["Character"]:GetChildren() do

	if v:IsA("Accessory") then

		if hatnameclone[v.Name] then

			if hatnameclone[v.Name] == "s" then

				hatnameclone[v.Name] = {}

			end

			table.insert(hatnameclone[v.Name],v)

		else

			hatnameclone[v.Name] = "s"

		end

	end

end

for _,v in pairs(hatnameclone) do

	if type(v) == "table" then

		local num = 1

		for _,w in pairs(v) do

			w.Name = w.Name..num

			num = num + 1

		end

	end

end

hatnameclone = nil

local CloneChar = game:FindFirstChildOfClass("Players").LocalPlayer["Character"]:Clone()

CloneChar.Parent = game:FindFirstChildOfClass("Workspace"):FindFirstChildOfClass("Terrain")

CloneChar.HumanoidRootPart.CFrame = game:FindFirstChildOfClass("Players").LocalPlayer["Character"].HumanoidRootPart.CFrame

CloneChar.Humanoid.BreakJointsOnDeath = false

CloneChar.Name = "non" 

CloneChar.Humanoid.DisplayDistanceType = "None"

local DeadChar = game:FindFirstChildOfClass("Players").LocalPlayer.Character

for _,v in next, DeadChar:GetChildren() do

	if v:IsA("Accessory") then

		local topacc = false

		if v.Handle:FindFirstChildOfClass("Weld") then v.Handle:FindFirstChildOfClass("Weld"):Destroy() end

		if v.Handle:FindFirstChildOfClass("Attachment") then

			local ath__ = v.Handle:FindFirstChildOfClass("Attachment")

			if ath__.Name == "HatAttachment" or ath__.Name == "HairAttachment" or ath__.Name == "FaceFrontAttachment" or ath__.Name == "FaceCenterAttachment" then

				topacc = ath__.Name

			end

		end

        local bv = Instance.new("BodyVelocity",v.Handle)

		bv.Velocity = Vector3.new(0,0,0)

		coroutine.wrap(function()

			if topacc then

				local allthings = SCIFIMOVIELOL(v.Handle,DeadChar.Torso,Vector3.new(0,1.5,0)+ (DeadChar.Head[topacc].Position + (v.Handle[topacc].Position*-1)),Vector3.new(0,0,0))

				local normaltop = allthings[1].Attachment1

				local alipos = allthings[1]

				local alirot = allthings[4]

				local p0 = v.Handle

				local p1 = DeadChar.Head

				while true do

					game:GetService("RunService").RenderStepped:wait()

					if HumanDied then break end

					coroutine.wrap(function()

						if alipos.Attachment1 == normaltop then

							p0.CFrame = (((DeadChar.Torso.CFrame * CFrame.new(0,1.5,0)) * p1[topacc].CFrame) * p0[topacc].CFrame:inverse())

						else

							v.Handle.CFrame = alipos.Attachment1.Parent.CFrame * CFrame.new(alipos.Attachment1.Position) * CFrame.Angles(math.rad(alirot.Attachment1.Rotation.X),math.rad(alirot.Attachment1.Rotation.Y),math.rad(alirot.Attachment1.Rotation.Z))

						end

					end)()

				end

			else

				SCIFIMOVIELOL(v.Handle,CloneChar[v.Name].Handle,Vector3.new(0,0,0),Vector3.new(0,0,0))

				--[[while true do

					game:GetService("RunService").RenderStepped:wait()

					if HumanDied then break end

					local alipos = CloneChar[v.Name].Handle:FindFirstChildOfClass("AlignPosition")

					local alirot = CloneChar[v.Name].Handle:FindFirstChildOfClass("AlignOrientation")

					v.Handle.CFrame = alipos.Attachment1.Parent.CFrame * CFrame.new(alipos.Attachment1.Position) * CFrame.Angles(math.rad(alirot.Attachment1.Rotation.X),math.rad(alirot.Attachment1.Rotation.Y),math.rad(alirot.Attachment1.Rotation.Z))

				end]]

			end

		end)()

    end

end

game:FindFirstChildOfClass("Players").LocalPlayer.Character = CloneChar

game:FindFirstChildOfClass("Players").LocalPlayer.Character = DeadChar

local a = DeadChar.Torso

local b = DeadChar.HumanoidRootPart

local c = DeadChar.Humanoid

a.Parent = game:FindFirstChildOfClass("Workspace")

c.Parent = game:FindFirstChildOfClass("Workspace")

local told = a:Clone()

local told1 = c:Clone()

b["RootJoint"].Part0 = told

b["RootJoint"].Part1 = DeadChar.Head

a.Name = "torso"

a.Neck:Destroy()

c.Name = "hum"

told.Parent = DeadChar

told1.Parent = DeadChar

DeadChar.PrimaryPart = told

told1.Health = 0

a.Parent = DeadChar

c.Parent = DeadChar

b:Destroy()

told:Destroy()

told1:Destroy()

a.Name = "Torso"

if CloneChar.Head:FindFirstChildOfClass("Decal") then CloneChar.Head:FindFirstChildOfClass("Decal").Transparency = 1 end

if DeadChar:FindFirstChild("Animate") then DeadChar:FindFirstChild("Animate"):Destroy() end

local Collider

function UnCollide()

    if HumanDied then Collider:Disconnect(); return end

    --[[for _,Parts in next, CloneChar:GetDescendants() do

        if Parts:IsA("BasePart") then

            Parts.CanCollide = false 

        end 

    end]]

    for _,Parts in next, DeadChar:GetDescendants() do

        if Parts:IsA("BasePart") then

        Parts.CanCollide = false

        end 

    end 

end

Collider = game:GetService("RunService").Stepped:Connect(UnCollide)

local resetBindable = Instance.new("BindableEvent")

resetBindable.Event:connect(function()

    game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)

	resetBindable:Destroy()

	HumanDied = true

    pcall(function()

        game:FindFirstChildOfClass("Players").LocalPlayer.Character = DeadChar

		DeadChar.hum.Name = "Humanoid"

		DeadChar.Humanoid.Health = 0

		DeadChar.Head:Destroy()

        game:FindFirstChildOfClass("Players").LocalPlayer.Character = CloneChar

        CloneChar.Humanoid.Health = 0

        CloneChar.Head:Destroy()

        for _,v in pairs(game:FindFirstChildOfClass("Workspace"):FindFirstChildOfClass("Terrain"):GetChildren()) do

			if v.Name == "non" then

				v:Destroy()

			end

		end

    end)

end)

game:GetService("StarterGui"):SetCore("ResetButtonCallback", resetBindable)

coroutine.wrap(function()

    while true do

        game:GetService("RunService").RenderStepped:wait()

        if not CloneChar or not CloneChar:FindFirstChild("Head") or not CloneChar:FindFirstChild("Humanoid") or CloneChar:FindFirstChild("Humanoid").Health <= 0 and not DeadChar or not DeadChar:FindFirstChild("Head") or not DeadChar:FindFirstChild("hum") or DeadChar:FindFirstChild("hum").Health <= 0 then 

            HumanDied = true

            pcall(function()

                game:FindFirstChildOfClass("Players").LocalPlayer.Character = DeadChar

                DeadChar.hum.Name = "Humanoid"

				DeadChar.Humanoid.Health = 0

				DeadChar.Head:Destroy()

                game:FindFirstChildOfClass("Players").LocalPlayer.Character = CloneChar

                CloneChar.Humanoid.Health = 0

                CloneChar.Head:Destroy()

				for _,v in pairs(game:FindFirstChildOfClass("Workspace"):FindFirstChildOfClass("Terrain"):GetChildren()) do

					if v.Name == "non" then

						v:Destroy()

					end

				end

            end)

            if resetBindable then

                game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)

                resetBindable:Destroy()

            end

            break

        end		

    end

end)()

SCIFIMOVIELOL(DeadChar["Head"],CloneChar["Head"],Vector3.new(0,0,0),Vector3.new(0,0,0))

SCIFIMOVIELOL(DeadChar["Torso"],CloneChar["Torso"],Vector3.new(0,0,0),Vector3.new(0,0,0))

SCIFIMOVIELOL(DeadChar["Left Arm"],CloneChar["Left Arm"],Vector3.new(0,0,0),Vector3.new(0,0,0))

SCIFIMOVIELOL(DeadChar["Right Arm"],CloneChar["Right Arm"],Vector3.new(0,0,0),Vector3.new(0,0,0))

SCIFIMOVIELOL(DeadChar["Left Leg"],CloneChar["Left Leg"],Vector3.new(0,0,0),Vector3.new(0,0,0))

SCIFIMOVIELOL(DeadChar["Right Leg"],CloneChar["Right Leg"],Vector3.new(0,0,0),Vector3.new(0,0,0))

for _,v in pairs(DeadChar:GetChildren()) do

	if v:IsA("BasePart") and v.Name ~= "Head" then

		--[[local bv = Instance.new("BodyVelocity",v)

		bv.Velocity = Vector3.new(0,0,0)

		coroutine.wrap(function()

			while true do

				game:GetService("RunService").RenderStepped:wait()

				if HumanDied then break end

				v.CFrame = CloneChar[v.Name].CFrame

			end

		end)()]]

	elseif v:IsA("BasePart") and v.Name == "Head" then

		local bv = Instance.new("BodyVelocity",v)

		bv.Velocity = Vector3.new(0,0,0)

		coroutine.wrap(function()

			while true do

				game:GetService("RunService").RenderStepped:wait()

				if HumanDied then break end

				v.CFrame = DeadChar.Torso.CFrame * CFrame.new(0,1.5,0)

			end

		end)()

	end

end

for _,BodyParts in next, CloneChar:GetDescendants() do

if BodyParts:IsA("BasePart") or BodyParts:IsA("Part") then

BodyParts.Transparency = 1 end end

game:GetService("RunService").RenderStepped:wait()

game:FindFirstChildOfClass("Players").LocalPlayer.Character = CloneChar

game:FindFirstChildOfClass("Workspace"):FindFirstChildOfClass("Camera").CameraSubject = CloneChar.Humanoid

function RUNANIMATESCRIPT(FOLDER)

local Figure = FOLDER.Parent

local Torso = Figure:WaitForChild("Torso")

local RightShoulder = Torso:WaitForChild("Right Shoulder")

local LeftShoulder = Torso:WaitForChild("Left Shoulder")

local RightHip = Torso:WaitForChild("Right Hip")

local LeftHip = Torso:WaitForChild("Left Hip")

local Neck = Torso:WaitForChild("Neck")

local Humanoid = Figure:WaitForChild("Humanoid")

local pose = "Standing"

local currentAnim = ""

local currentAnimInstance = nil

local currentAnimTrack = nil

local currentAnimKeyframeHandler = nil

local currentAnimSpeed = 1.0

local animTable = {}

local animNames = { 

	idle = 	{	

				{ id = "http://www.roblox.com/asset/?id=180435571", weight = 9 },

				{ id = "http://www.roblox.com/asset/?id=180435792", weight = 1 }

			},

	walk = 	{ 	

				{ id = "http://www.roblox.com/asset/?id=180426354", weight = 10 } 

			}, 

	run = 	{

				{ id = "run.xml", weight = 10 } 

			}, 

	jump = 	{

				{ id = "http://www.roblox.com/asset/?id=125750702", weight = 10 } 

			}, 

	fall = 	{

				{ id = "http://www.roblox.com/asset/?id=180436148", weight = 10 } 

			}, 

	climb = {

				{ id = "http://www.roblox.com/asset/?id=180436334", weight = 10 } 

			}, 

	sit = 	{

				{ id = "http://www.roblox.com/asset/?id=178130996", weight = 10 } 

			},	

	toolnone = {

				{ id = "http://www.roblox.com/asset/?id=182393478", weight = 10 } 

			},

	toolslash = {

				{ id = "http://www.roblox.com/asset/?id=129967390", weight = 10 } 

--				{ id = "slash.xml", weight = 10 } 

			},

	toollunge = {

				{ id = "http://www.roblox.com/asset/?id=129967478", weight = 10 } 

			},

	wave = {

				{ id = "http://www.roblox.com/asset/?id=128777973", weight = 10 } 

			},

	point = {

				{ id = "http://www.roblox.com/asset/?id=128853357", weight = 10 } 

			},

	dance1 = {

				{ id = "http://www.roblox.com/asset/?id=182435998", weight = 10 }, 

				{ id = "http://www.roblox.com/asset/?id=182491037", weight = 10 }, 

				{ id = "http://www.roblox.com/asset/?id=182491065", weight = 10 } 

			},

	dance2 = {

				{ id = "http://www.roblox.com/asset/?id=182436842", weight = 10 }, 

				{ id = "http://www.roblox.com/asset/?id=182491248", weight = 10 }, 

				{ id = "http://www.roblox.com/asset/?id=182491277", weight = 10 } 

			},

	dance3 = {

				{ id = "http://www.roblox.com/asset/?id=182436935", weight = 10 }, 

				{ id = "http://www.roblox.com/asset/?id=182491368", weight = 10 }, 

				{ id = "http://www.roblox.com/asset/?id=182491423", weight = 10 } 

			},

	laugh = {

				{ id = "http://www.roblox.com/asset/?id=129423131", weight = 10 } 

			},

	cheer = {

				{ id = "http://www.roblox.com/asset/?id=129423030", weight = 10 } 

			},

}

local dances = {"dance1", "dance2", "dance3"}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote

local emoteNames = { wave = false, point = false, dance1 = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

function configureAnimationSet(name, fileList)

	if (animTable[name] ~= nil) then

		for _, connection in pairs(animTable[name].connections) do

			connection:disconnect()

		end

	end

	animTable[name] = {}

	animTable[name].count = 0

	animTable[name].totalWeight = 0	

	animTable[name].connections = {}

	-- check for config values

	local config = FOLDER:FindFirstChild(name)

	if (config ~= nil) then

--		print("Loading anims " .. name)

		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))

		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))

		local idx = 1

		for _, childPart in pairs(config:GetChildren()) do

			if (childPart:IsA("Animation")) then

				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))

				animTable[name][idx] = {}

				animTable[name][idx].anim = childPart

				local weightObject = childPart:FindFirstChild("Weight")

				if (weightObject == nil) then

					animTable[name][idx].weight = 1

				else

					animTable[name][idx].weight = weightObject.Value

				end

				animTable[name].count = animTable[name].count + 1

				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight

	--			print(name .. " [" .. idx .. "] " .. animTable[name][idx].anim.AnimationId .. " (" .. animTable[name][idx].weight .. ")")

				idx = idx + 1

			end

		end

	end

	-- fallback to defaults

	if (animTable[name].count <= 0) then

		for idx, anim in pairs(fileList) do

			animTable[name][idx] = {}

			animTable[name][idx].anim = Instance.new("Animation")

			animTable[name][idx].anim.Name = name

			animTable[name][idx].anim.AnimationId = anim.id

			animTable[name][idx].weight = anim.weight

			animTable[name].count = animTable[name].count + 1

			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight

--			print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")

		end

	end

end

-- Setup animation objects

function scriptChildModified(child)

	local fileList = animNames[child.Name]

	if (fileList ~= nil) then

		configureAnimationSet(child.Name, fileList)

	end	

end

FOLDER.ChildAdded:connect(scriptChildModified)

FOLDER.ChildRemoved:connect(scriptChildModified)

for name, fileList in pairs(animNames) do 

	configureAnimationSet(name, fileList)

end	

-- ANIMATION

-- declarations

local toolAnim = "None"

local toolAnimTime = 0

local jumpAnimTime = 0

local jumpAnimDuration = 0.3

local toolTransitionTime = 0.1

local fallTransitionTime = 0.3

local jumpMaxLimbVelocity = 0.75

-- functions

function stopAllAnimations()

	local oldAnim = currentAnim

	-- return to idle if finishing an emote

	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then

		oldAnim = "idle"

	end

	currentAnim = ""

	currentAnimInstance = nil

	if (currentAnimKeyframeHandler ~= nil) then

		currentAnimKeyframeHandler:disconnect()

	end

	if (currentAnimTrack ~= nil) then

		currentAnimTrack:Stop()

		currentAnimTrack:Destroy()

		currentAnimTrack = nil

	end

	return oldAnim

end

function setAnimationSpeed(speed)

	if speed ~= currentAnimSpeed then

		currentAnimSpeed = speed

		currentAnimTrack:AdjustSpeed(currentAnimSpeed)

	end

end

function keyFrameReachedFunc(frameName)

	if (frameName == "End") then

		local repeatAnim = currentAnim

		-- return to idle if finishing an emote

		if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then

			repeatAnim = "idle"

		end

		

		local animSpeed = currentAnimSpeed

		playAnimation(repeatAnim, 0.0, Humanoid)

		setAnimationSpeed(animSpeed)

	end

end

-- Preload animations

function playAnimation(animName, transitionTime, humanoid) 

		

	local roll = math.random(1, animTable[animName].totalWeight) 

	local origRoll = roll

	local idx = 1

	while (roll > animTable[animName][idx].weight) do

		roll = roll - animTable[animName][idx].weight

		idx = idx + 1

	end

--		print(animName .. " " .. idx .. " [" .. origRoll .. "]")

	local anim = animTable[animName][idx].anim

	-- switch animation		

	if (anim ~= currentAnimInstance) then

		

		if (currentAnimTrack ~= nil) then

			currentAnimTrack:Stop(transitionTime)

			currentAnimTrack:Destroy()

		end

		currentAnimSpeed = 1.0

	

		-- load it to the humanoid; get AnimationTrack

		currentAnimTrack = humanoid:LoadAnimation(anim)

		currentAnimTrack.Priority = Enum.AnimationPriority.Core

			

		-- play the animation

		currentAnimTrack:Play(transitionTime)

		currentAnim = animName

		currentAnimInstance = anim

		-- set up keyframe name triggers

		if (currentAnimKeyframeHandler ~= nil) then

			currentAnimKeyframeHandler:disconnect()

		end

		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)

		

	end

end

-------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------------

local toolAnimName = ""

local toolAnimTrack = nil

local toolAnimInstance = nil

local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)

	if (frameName == "End") then

--		print("Keyframe : ".. frameName)	

		playToolAnimation(toolAnimName, 0.0, Humanoid)

	end

end

function playToolAnimation(animName, transitionTime, humanoid, priority)	 

		

		local roll = math.random(1, animTable[animName].totalWeight) 

		local origRoll = roll

		local idx = 1

		while (roll > animTable[animName][idx].weight) do

			roll = roll - animTable[animName][idx].weight

			idx = idx + 1

		end

--		print(animName .. " * " .. idx .. " [" .. origRoll .. "]")

		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then

			

			if (toolAnimTrack ~= nil) then

				toolAnimTrack:Stop()

				toolAnimTrack:Destroy()

				transitionTime = 0

			end

					

			-- load it to the humanoid; get AnimationTrack

			toolAnimTrack = humanoid:LoadAnimation(anim)

			if priority then

				toolAnimTrack.Priority = priority

			end

				

			-- play the animation

			toolAnimTrack:Play(transitionTime)

			toolAnimName = animName

			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)

		end

end

function stopToolAnimations()

	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then

		currentToolAnimKeyframeHandler:disconnect()

	end

	toolAnimName = ""

	toolAnimInstance = nil

	if (toolAnimTrack ~= nil) then

		toolAnimTrack:Stop()

		toolAnimTrack:Destroy()

		toolAnimTrack = nil

	end

	return oldAnim

end

-------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------------

function onRunning(speed)

	if speed > 0.01 then

		playAnimation("walk", 0.1, Humanoid)

		if currentAnimInstance and currentAnimInstance.AnimationId == "http://www.roblox.com/asset/?id=180426354" then

			setAnimationSpeed(speed / 14.5)

		end

		pose = "Running"

	else

		if emoteNames[currentAnim] == nil then

			playAnimation("idle", 0.1, Humanoid)

			pose = "Standing"

		end

	end

end

function onDied()

	pose = "Dead"

end

function onJumping()

	playAnimation("jump", 0.1, Humanoid)

	jumpAnimTime = jumpAnimDuration

	pose = "Jumping"

end

function onClimbing(speed)

	playAnimation("climb", 0.1, Humanoid)

	setAnimationSpeed(speed / 12.0)

	pose = "Climbing"

end

function onGettingUp()

	pose = "GettingUp"

end

function onFreeFall()

	if (jumpAnimTime <= 0) then

		playAnimation("fall", fallTransitionTime, Humanoid)

	end

	pose = "FreeFall"

end

function onFallingDown()

	pose = "FallingDown"

end

function onSeated()

	pose = "Seated"

end

function onPlatformStanding()

	pose = "PlatformStanding"

end

function onSwimming(speed)

	if speed > 0 then

		pose = "Running"

	else

		pose = "Standing"

	end

end

function getTool()	

	for _, kid in ipairs(Figure:GetChildren()) do

		if kid.className == "Tool" then return kid end

	end

	return nil

end

function getToolAnim(tool)

	for _, c in ipairs(tool:GetChildren()) do

		if c.Name == "toolanim" and c.className == "StringValue" then

			return c

		end

	end

	return nil

end

function animateTool()

	

	if (toolAnim == "None") then

		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)

		return

	end

	if (toolAnim == "Slash") then

		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)

		return

	end

	if (toolAnim == "Lunge") then

		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)

		return

	end

end

function moveSit()

	RightShoulder.MaxVelocity = 0.15

	LeftShoulder.MaxVelocity = 0.15

	RightShoulder:SetDesiredAngle(3.14 /2)

	LeftShoulder:SetDesiredAngle(-3.14 /2)

	RightHip:SetDesiredAngle(3.14 /2)

	LeftHip:SetDesiredAngle(-3.14 /2)

end

local lastTick = 0

function move(time)

	local amplitude = 1

	local frequency = 1

		local deltaTime = time - lastTick

		lastTick = time

	local climbFudge = 0

	local setAngles = false

		if (jumpAnimTime > 0) then

			jumpAnimTime = jumpAnimTime - deltaTime

		end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then

		playAnimation("fall", fallTransitionTime, Humanoid)

	elseif (pose == "Seated") then

		playAnimation("sit", 0.5, Humanoid)

		return

	elseif (pose == "Running") then

		playAnimation("walk", 0.1, Humanoid)

	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then

--		print("Wha " .. pose)

		stopAllAnimations()

		amplitude = 0.1

		frequency = 1

		setAngles = true

	end

	if (setAngles) then

		local desiredAngle = amplitude * math.sin(time * frequency)

		RightShoulder:SetDesiredAngle(desiredAngle + climbFudge)

		LeftShoulder:SetDesiredAngle(desiredAngle - climbFudge)

		RightHip:SetDesiredAngle(-desiredAngle)

		LeftHip:SetDesiredAngle(-desiredAngle)

	end

	-- Tool Animation handling

	local tool = getTool()

	if tool and tool:FindFirstChild("Handle") then

	

		local animStringValueObject = getToolAnim(tool)

		if animStringValueObject then

			toolAnim = animStringValueObject.Value

			-- message recieved, delete StringValue

			animStringValueObject.Parent = nil

			toolAnimTime = time + .3

		end

		if time > toolAnimTime then

			toolAnimTime = 0

			toolAnim = "None"

		end

		animateTool()		

	else

		stopToolAnimations()

		toolAnim = "None"

		toolAnimInstance = nil

		toolAnimTime = 0

	end

end

local events = {}

local eventHum = Humanoid

local function onUnhook()

	for i = 1, #events do

		events[i]:Disconnect()

	end

	events = {}

end

local function onHook()

	onUnhook()

	

	pose = eventHum.Sit and "Seated" or "Standing"

	

	events = {

		eventHum.Died:connect(onDied),

		eventHum.Running:connect(onRunning),

		eventHum.Jumping:connect(onJumping),

		eventHum.Climbing:connect(onClimbing),

		eventHum.GettingUp:connect(onGettingUp),

		eventHum.FreeFalling:connect(onFreeFall),

		eventHum.FallingDown:connect(onFallingDown),

		eventHum.Seated:connect(onSeated),

		eventHum.PlatformStanding:connect(onPlatformStanding),

		eventHum.Swimming:connect(onSwimming)

	}

end

onHook()

--FOLDER:WaitForChild("Loaded").Value = true

-- main program

-- initialize to idle

playAnimation("idle", 0.1, Humanoid)

pose = "Standing"

spawn(function()

	while Figure.Parent ~= nil do

		local _, time = wait(0.1)

		move(time)

	end

end)

return {

	onRunning = onRunning, 

	onDied = onDied, 

	onJumping = onJumping, 

	onClimbing = onClimbing, 

	onGettingUp = onGettingUp, 

	onFreeFall = onFreeFall, 

	onFallingDown = onFallingDown, 

	onSeated = onSeated, 

	onPlatformStanding = onPlatformStanding,

	onHook = onHook,

	onUnhook = onUnhook

}

end

RUNANIMATESCRIPT(CloneChar.Animate)

end)-- a title

main:createbutton("R6 V2", function() -- add a button

local chr = game.Players.LocalPlayer.Character

local chr = game.Players.LocalPlayer.Character

        for _,v in pairs(chr:GetChildren()) do

            if v:IsA("BallSocketConstraint") or v:IsA("HingeConstraint") then

                v:Destroy()

            end

        end

            

        

local function nocloloop()

if  game.Players.LocalPlayer.Character.Humanoid.RigType == Enum.HumanoidRigType.R15 then

for _, child in pairs(game.Players.LocalPlayer.Character:GetDescendants()) do

if child:IsA("BasePart") and child.CanCollide == true then

child.CanCollide = false

end

end

end

end

Noclipping = game:GetService('RunService').Stepped:connect(nocloloop)

local Player = game.Players.LocalPlayer

local Character = Player.Character

if Character.Humanoid.RigType == Enum.HumanoidRigType.R15 then

    

Character.RightUpperArm["RightShoulder"]:Destroy()

Character.LeftUpperArm["LeftShoulder"]:Destroy()

Character.LeftUpperLeg["LeftHip"]:Destroy()

Character.RightUpperLeg["RightHip"]:Destroy()

else

Character.Torso["Right Shoulder"]:Destroy()

Character.Torso["Left Shoulder"]:Destroy()

Character.Torso["Right Hip"]:Destroy()

Character.Torso["Left Hip"]:Destroy()

end

local Leftarm = Character:FindFirstChild("Left Arm") or Character:FindFirstChild("LeftUpperArm")

local Rightarm = Character:FindFirstChild("Right Arm") or Character:FindFirstChild("RightUpperArm")

local Torso = Character:FindFirstChild("Torso") or Character:FindFirstChild("UpperTorso")

local Leftleg = Character:FindFirstChild("Left Leg") or Character:FindFirstChild("LeftUpperLeg")

local Rightleg = Character:FindFirstChild("Right Leg") or Character:FindFirstChild("RightUpperLeg")

local rig = game:GetObjects("rbxassetid://6020146689")[1]

rig.Parent = Character

rig:MoveTo(game.Players.LocalPlayer.Character.HumanoidRootPart.Position)

rig.Humanoid:Move(game.Players.LocalPlayer.Character.Humanoid.MoveDirection, false)

rig.Torso.Anchored = false

if Character.Humanoid.RigType == Enum.HumanoidRigType.R15 then

alignPosition = Instance.new("AlignPosition",Leftarm)

alignPosition.RigidityEnabled = false

alignPosition.ApplyAtCenterOfMass = false

alignPosition.MaxForce = 9e9

alignPosition.MaxVelocity = 9e99

alignPosition.ReactionForceEnabled = false

alignPosition.Responsiveness = 9e99

--alignPosition.Parent = Leftarm

alignOr = Instance.new("AlignOrientation",Leftarm)

alignOr.MaxTorque = 9e99

alignOr.MaxAngularVelocity = 9e99

alignOr.PrimaryAxisOnly = false

alignOr.ReactionTorqueEnabled = false

alignOr.Responsiveness = 200

alignOr.RigidityEnabled = false

--alignOr.Parent = Leftarm

--Rightarm

alignPosition = Instance.new("AlignPosition",Rightarm)

alignPosition.RigidityEnabled = false

alignPosition.ApplyAtCenterOfMass = false

alignPosition.MaxForce = 9e9

alignPosition.MaxVelocity = 9e99

alignPosition.ReactionForceEnabled = false

alignPosition.Responsiveness = 9e99

--alignPosition.Parent = Rightarm

alignOr = Instance.new("AlignOrientation",Rightarm)

alignOr.MaxTorque = 9e99

alignOr.MaxAngularVelocity = 9e99

alignOr.PrimaryAxisOnly = false

alignOr.ReactionTorqueEnabled = false

alignOr.Responsiveness = 200

alignOr.RigidityEnabled = false

--alignOr.Parent = Rightarm

--Torso

alignPosition = Instance.new("AlignPosition",Torso)

alignPosition.RigidityEnabled = false

alignPosition.ApplyAtCenterOfMass = false

alignPosition.MaxForce = 9e9

alignPosition.MaxVelocity = 9e99

alignPosition.ReactionForceEnabled = false

alignPosition.Responsiveness = 9e99

--alignPosition.Parent = Torso

alignOr = Instance.new("AlignOrientation",Torso)

alignOr.MaxTorque = 9e99

alignOr.MaxAngularVelocity = 9e99

alignOr.PrimaryAxisOnly = false

alignOr.ReactionTorqueEnabled = false

alignOr.Responsiveness = 200

alignOr.RigidityEnabled = false

--alignOr.Parent = Torso

--LeftLeg

alignPosition = Instance.new("AlignPosition",Leftleg)

alignPosition.RigidityEnabled = false

alignPosition.ApplyAtCenterOfMass = false

alignPosition.MaxForce = 9e9

alignPosition.MaxVelocity = 9e99

alignPosition.ReactionForceEnabled = false

alignPosition.Responsiveness = 9e99

alignPosition.Parent = Leftleg

alignOr = Instance.new("AlignOrientation",Leftleg)

alignOr.MaxTorque = 9e99

alignOr.MaxAngularVelocity = 9e99

alignOr.PrimaryAxisOnly = false

alignOr.ReactionTorqueEnabled = false

alignOr.Responsiveness = 200

alignOr.RigidityEnabled = false

--alignOr.Parent = Leftleg

--Rightleg

alignPosition = Instance.new("AlignPosition",Rightleg)

alignPosition.RigidityEnabled = false

alignPosition.ApplyAtCenterOfMass = false

alignPosition.MaxForce = 9e9

alignPosition.MaxVelocity = 9e99

alignPosition.ReactionForceEnabled = false

alignPosition.Responsiveness = 9e99

alignPosition.Parent = Rightleg

alignOr = Instance.new("AlignOrientation",Rightleg)

alignOr.MaxTorque = 9e99

alignOr.MaxAngularVelocity = 9e99

alignOr.PrimaryAxisOnly = false

alignOr.ReactionTorqueEnabled = false

alignOr.Responsiveness = 200

alignOr.RigidityEnabled = false

--alignOr.Parent = Rightleg

a0 = Instance.new("Attachment",Rightarm)

a0.Position = Vector3.new(0, -0.4, 0)

a1 = Instance.new("Attachment",rig["Right Arm"])

a2 = Instance.new("Attachment",Rightarm)

Rightarm.AlignPosition.Attachment0 = a0

Rightarm.AlignPosition.Attachment1 = a1

Rightarm.AlignOrientation.Attachment0 = a2

Rightarm.AlignOrientation.Attachment1 = a1

a0 = Instance.new("Attachment",Leftarm)

a0.Position = Vector3.new(0, -0.4, 0)

a1 = Instance.new("Attachment",rig["Left Arm"])

a2 = Instance.new("Attachment",Leftarm)

Leftarm.AlignPosition.Attachment0 = a0

Leftarm.AlignPosition.Attachment1 = a1

Leftarm.AlignOrientation.Attachment0 = a2

Leftarm.AlignOrientation.Attachment1 = a1

a0 = Instance.new("Attachment",Torso)

a0.Position = Vector3.new(0, -0.2, 0)

a1 = Instance.new("Attachment",rig["Torso"])

a2 = Instance.new("Attachment",Torso)

Torso.AlignPosition.Attachment0 = a0

Torso.AlignPosition.Attachment1 = a1

Torso.AlignOrientation.Attachment0 = a2

Torso.AlignOrientation.Attachment1 = a1

a0 = Instance.new("Attachment",Leftleg)

a0.Position = Vector3.new(0, -0.5, 0)

a1 = Instance.new("Attachment",rig["Left Leg"])

a2 = Instance.new("Attachment",Leftleg)

Leftleg.AlignPosition.Attachment0 = a0

Leftleg.AlignPosition.Attachment1 = a1

Leftleg.AlignOrientation.Attachment0 = a2

Leftleg.AlignOrientation.Attachment1 = a1

a0 = Instance.new("Attachment",Rightleg)

a0.Position = Vector3.new(0, -0.5, 0)

a1 = Instance.new("Attachment",rig["Right Leg"])

a2 = Instance.new("Attachment",Rightleg)

Rightleg.AlignPosition.Attachment0 = a0

Rightleg.AlignPosition.Attachment1 = a1

Rightleg.AlignOrientation.Attachment0 = a2

Rightleg.AlignOrientation.Attachment1 = a1

else 

alignPosition = Instance.new("AlignPosition",Leftarm)

alignPosition.RigidityEnabled = false

alignPosition.ApplyAtCenterOfMass = false

alignPosition.MaxForce = 9e9

alignPosition.MaxVelocity = 9e99

alignPosition.ReactionForceEnabled = false

alignPosition.Responsiveness = 9e99

--alignPosition.Parent = Leftarm

alignOr = Instance.new("AlignOrientation",Leftarm)

alignOr.MaxTorque = 9e99

alignOr.MaxAngularVelocity = 9e99

alignOr.PrimaryAxisOnly = false

alignOr.ReactionTorqueEnabled = false

alignOr.Responsiveness = 200

alignOr.RigidityEnabled = false

--alignOr.Parent = Leftarm

--Rightarm

alignPosition = Instance.new("AlignPosition",Rightarm)

alignPosition.RigidityEnabled = false

alignPosition.ApplyAtCenterOfMass = false

alignPosition.MaxForce = 9e9

alignPosition.MaxVelocity = 9e99

alignPosition.ReactionForceEnabled = false

alignPosition.Responsiveness = 9e99

--alignPosition.Parent = Rightarm

alignOr = Instance.new("AlignOrientation",Rightarm)

alignOr.MaxTorque = 9e99

alignOr.MaxAngularVelocity = 9e99

alignOr.PrimaryAxisOnly = false

alignOr.ReactionTorqueEnabled = false

alignOr.Responsiveness = 200

alignOr.RigidityEnabled = false

--alignOr.Parent = Rightarm

--Torso

alignPosition = Instance.new("AlignPosition",Torso)

alignPosition.RigidityEnabled = false

alignPosition.ApplyAtCenterOfMass = false

alignPosition.MaxForce = 9e9

alignPosition.MaxVelocity = 9e99

alignPosition.ReactionForceEnabled = false

alignPosition.Responsiveness = 9e99

--alignPosition.Parent = Torso

alignOr = Instance.new("AlignOrientation",Torso)

alignOr.MaxTorque = 9e99

alignOr.MaxAngularVelocity = 9e99

alignOr.PrimaryAxisOnly = false

alignOr.ReactionTorqueEnabled = false

alignOr.Responsiveness = 200

alignOr.RigidityEnabled = false

--alignOr.Parent = Torso

--LeftLeg

alignPosition = Instance.new("AlignPosition",Leftleg)

alignPosition.RigidityEnabled = false

alignPosition.ApplyAtCenterOfMass = false

alignPosition.MaxForce = 9e9

alignPosition.MaxVelocity = 9e99

alignPosition.ReactionForceEnabled = false

alignPosition.Responsiveness = 9e99

alignPosition.Parent = Leftleg

alignOr = Instance.new("AlignOrientation",Leftleg)

alignOr.MaxTorque = 9e99

alignOr.MaxAngularVelocity = 9e99

alignOr.PrimaryAxisOnly = false

alignOr.ReactionTorqueEnabled = false

alignOr.Responsiveness = 200

alignOr.RigidityEnabled = false

--alignOr.Parent = Leftleg

--Rightleg

alignPosition = Instance.new("AlignPosition",Rightleg)

alignPosition.RigidityEnabled = false

alignPosition.ApplyAtCenterOfMass = false

alignPosition.MaxForce = 9e9

alignPosition.MaxVelocity = 9e99

alignPosition.ReactionForceEnabled = false

alignPosition.Responsiveness = 9e99

alignPosition.Parent = Rightleg

alignOr = Instance.new("AlignOrientation",Rightleg)

alignOr.MaxTorque = 9e99

alignOr.MaxAngularVelocity = 9e99

alignOr.PrimaryAxisOnly = false

alignOr.ReactionTorqueEnabled = false

alignOr.Responsiveness = 200

alignOr.RigidityEnabled = false

--alignOr.Parent = Rightleg

a0 = Instance.new("Attachment",Rightarm)

a1 = Instance.new("Attachment",rig["Right Arm"])

a2 = Instance.new("Attachment",Rightarm)

Rightarm.AlignPosition.Attachment0 = a0

Rightarm.AlignPosition.Attachment1 = a1

Rightarm.AlignOrientation.Attachment0 = a2

Rightarm.AlignOrientation.Attachment1 = a1

a0 = Instance.new("Attachment",Leftarm)

a1 = Instance.new("Attachment",rig["Left Arm"])

a2 = Instance.new("Attachment",Leftarm)

Leftarm.AlignPosition.Attachment0 = a0

Leftarm.AlignPosition.Attachment1 = a1

Leftarm.AlignOrientation.Attachment0 = a2

Leftarm.AlignOrientation.Attachment1 = a1

a0 = Instance.new("Attachment",Torso)

a1 = Instance.new("Attachment",rig["Torso"])

a2 = Instance.new("Attachment",Torso)

Torso.AlignPosition.Attachment0 = a0

Torso.AlignPosition.Attachment1 = a1

Torso.AlignOrientation.Attachment0 = a2

Torso.AlignOrientation.Attachment1 = a1

a0 = Instance.new("Attachment",Leftleg)

a1 = Instance.new("Attachment",rig["Left Leg"])

a2 = Instance.new("Attachment",Leftleg)

Leftleg.AlignPosition.Attachment0 = a0

Leftleg.AlignPosition.Attachment1 = a1

Leftleg.AlignOrientation.Attachment0 = a2

Leftleg.AlignOrientation.Attachment1 = a1

a0 = Instance.new("Attachment",Rightleg)

a1 = Instance.new("Attachment",rig["Right Leg"])

a2 = Instance.new("Attachment",Rightleg)

Rightleg.AlignPosition.Attachment0 = a0

Rightleg.AlignPosition.Attachment1 = a1

Rightleg.AlignOrientation.Attachment0 = a2

Rightleg.AlignOrientation.Attachment1 = a1

end

rig.HumanoidRootPart.Anchored = false

spawn(function()

while true do

wait()

if Character:FindFirstChild("Humanoid").Health == 0 then

Character:BreakJoints()

rig:BreakJoints()

end

end

end)

function nocol(same)

for i,v in pairs(Character:GetDescendants()) do

if v:IsA("BasePart") then

HILOL=Instance.new("NoCollisionConstraint",v)

HILOL.Part0 = v

HILOL.Part1 = same

end

end

end

for i,v in pairs(rig:GetDescendants()) do

if v:IsA("BasePart") then

nocol(v)

end

end

spawn(function()

local Figure = rig.Animate.Parent

local Torso = Figure:WaitForChild("Torso")

local RightShoulder = Torso:WaitForChild("Right Shoulder")

local LeftShoulder = Torso:WaitForChild("Left Shoulder")

local RightHip = Torso:WaitForChild("Right Hip")

local LeftHip = Torso:WaitForChild("Left Hip")

local Neck = Torso:WaitForChild("Neck")

local Humanoid = Figure:WaitForChild("Humanoid")

local pose = "Standing"

local currentAnim = ""

local currentAnimInstance = nil

local currentAnimTrack = nil

local currentAnimKeyframeHandler = nil

local currentAnimSpeed = 1.0

local animTable = {}

local animNames = { 

	idle = 	{	

				{ id = "http://www.roblox.com/asset/?id=180435571", weight = 9 },

				{ id = "http://www.roblox.com/asset/?id=180435792", weight = 1 }

			},

	walk = 	{ 	

				{ id = "http://www.roblox.com/asset/?id=180426354", weight = 10 } 

			}, 

	run = 	{

				{ id = "run.xml", weight = 10 } 

			}, 

	jump = 	{

				{ id = "http://www.roblox.com/asset/?id=125750702", weight = 10 } 

			}, 

	fall = 	{

				{ id = "http://www.roblox.com/asset/?id=180436148", weight = 10 } 

			}, 

	climb = {

				{ id = "http://www.roblox.com/asset/?id=180436334", weight = 10 } 

			}, 

	sit = 	{

				{ id = "http://www.roblox.com/asset/?id=178130996", weight = 10 } 

			},	

	toolnone = {

				{ id = "http://www.roblox.com/asset/?id=182393478", weight = 10 } 

			},

	toolslash = {

				{ id = "http://www.roblox.com/asset/?id=129967390", weight = 10 } 

--				{ id = "slash.xml", weight = 10 } 

			},

	toollunge = {

				{ id = "http://www.roblox.com/asset/?id=129967478", weight = 10 } 

			},

	wave = {

				{ id = "http://www.roblox.com/asset/?id=128777973", weight = 10 } 

			},

	point = {

				{ id = "http://www.roblox.com/asset/?id=128853357", weight = 10 } 

			},

	dance1 = {

				{ id = "http://www.roblox.com/asset/?id=182435998", weight = 10 }, 

				{ id = "http://www.roblox.com/asset/?id=182491037", weight = 10 }, 

				{ id = "http://www.roblox.com/asset/?id=182491065", weight = 10 } 

			},

	dance2 = {

				{ id = "http://www.roblox.com/asset/?id=182436842", weight = 10 }, 

				{ id = "http://www.roblox.com/asset/?id=182491248", weight = 10 }, 

				{ id = "http://www.roblox.com/asset/?id=182491277", weight = 10 } 

			},

	dance3 = {

				{ id = "http://www.roblox.com/asset/?id=182436935", weight = 10 }, 

				{ id = "http://www.roblox.com/asset/?id=182491368", weight = 10 }, 

				{ id = "http://www.roblox.com/asset/?id=182491423", weight = 10 } 

			},

	laugh = {

				{ id = "http://www.roblox.com/asset/?id=129423131", weight = 10 } 

			},

	cheer = {

				{ id = "http://www.roblox.com/asset/?id=129423030", weight = 10 } 

			},

}

local dances = {"dance1", "dance2", "dance3"}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote

local emoteNames = { wave = false, point = false, dance1 = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

function configureAnimationSet(name, fileList)

	if (animTable[name] ~= nil) then

		for _, connection in pairs(animTable[name].connections) do

			connection:disconnect()

		end

	end

	animTable[name] = {}

	animTable[name].count = 0

	animTable[name].totalWeight = 0	

	animTable[name].connections = {}

	-- check for config values

	local config = rig.Animate:FindFirstChild(name)

	if (config ~= nil) then

--		print("Loading anims " .. name)

		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))

		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))

		local idx = 1

		for _, childPart in pairs(config:GetChildren()) do

			if (childPart:IsA("Animation")) then

				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))

				animTable[name][idx] = {}

				animTable[name][idx].anim = childPart

				local weightObject = childPart:FindFirstChild("Weight")

				if (weightObject == nil) then

					animTable[name][idx].weight = 1

				else

					animTable[name][idx].weight = weightObject.Value

				end

				animTable[name].count = animTable[name].count + 1

				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight

	--			print(name .. " [" .. idx .. "] " .. animTable[name][idx].anim.AnimationId .. " (" .. animTable[name][idx].weight .. ")")

				idx = idx + 1

			end

		end

	end

	-- fallback to defaults

	if (animTable[name].count <= 0) then

		for idx, anim in pairs(fileList) do

			animTable[name][idx] = {}

			animTable[name][idx].anim = Instance.new("Animation")

			animTable[name][idx].anim.Name = name

			animTable[name][idx].anim.AnimationId = anim.id

			animTable[name][idx].weight = anim.weight

			animTable[name].count = animTable[name].count + 1

			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight

--			print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")

		end

	end

end

-- Setup animation objects

function scriptChildModified(child)

	local fileList = animNames[child.Name]

	if (fileList ~= nil) then

		configureAnimationSet(child.Name, fileList)

	end	

end

rig.Animate.ChildAdded:connect(scriptChildModified)

rig.Animate.ChildRemoved:connect(scriptChildModified)

rig.HumanoidRootPart.Anchored = false

for name, fileList in pairs(animNames) do 

	configureAnimationSet(name, fileList)

end	

-- ANIMATION

-- declarations

local toolAnim = "None"

local toolAnimTime = 0

local jumpAnimTime = 0

local jumpAnimDuration = 0.3

local toolTransitionTime = 0.1

local fallTransitionTime = 0.3

local jumpMaxLimbVelocity = 0.75

-- functions

function stopAllAnimations()

	local oldAnim = currentAnim

	-- return to idle if finishing an emote

	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then

		oldAnim = "idle"

	end

	currentAnim = ""

	currentAnimInstance = nil

	if (currentAnimKeyframeHandler ~= nil) then

		currentAnimKeyframeHandler:disconnect()

	end

	if (currentAnimTrack ~= nil) then

		currentAnimTrack:Stop()

		currentAnimTrack:Destroy()

		currentAnimTrack = nil

	end

	return oldAnim

end

function setAnimationSpeed(speed)

	if speed ~= currentAnimSpeed then

		currentAnimSpeed = speed

		currentAnimTrack:AdjustSpeed(currentAnimSpeed)

	end

end

function keyFrameReachedFunc(frameName)

	if (frameName == "End") then

		local repeatAnim = currentAnim

		-- return to idle if finishing an emote

		if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then

			repeatAnim = "idle"

		end

		

		local animSpeed = currentAnimSpeed

		playAnimation(repeatAnim, 0.0, Humanoid)

		setAnimationSpeed(animSpeed)

	end

end

-- Preload animations

function playAnimation(animName, transitionTime, humanoid) 

		

	local roll = math.random(1, animTable[animName].totalWeight) 

	local origRoll = roll

	local idx = 1

	while (roll > animTable[animName][idx].weight) do

		roll = roll - animTable[animName][idx].weight

		idx = idx + 1

	end

--		print(animName .. " " .. idx .. " [" .. origRoll .. "]")

	local anim = animTable[animName][idx].anim

	-- switch animation		

	if (anim ~= currentAnimInstance) then

		

		if (currentAnimTrack ~= nil) then

			currentAnimTrack:Stop(transitionTime)

			currentAnimTrack:Destroy()

		end

		currentAnimSpeed = 1.0

	

		-- load it to the humanoid; get AnimationTrack

		currentAnimTrack = humanoid:LoadAnimation(anim)

		currentAnimTrack.Priority = Enum.AnimationPriority.Core

		 

		-- play the animation

		currentAnimTrack:Play(transitionTime)

		currentAnim = animName

		currentAnimInstance = anim

		-- set up keyframe name triggers

		if (currentAnimKeyframeHandler ~= nil) then

			currentAnimKeyframeHandler:disconnect()

		end

		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)

		

	end

end

-------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------------

local toolAnimName = ""

local toolAnimTrack = nil

local toolAnimInstance = nil

local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)

	if (frameName == "End") then

--		print("Keyframe : ".. frameName)	

		playToolAnimation(toolAnimName, 0.0, Humanoid)

	end

end

function playToolAnimation(animName, transitionTime, humanoid, priority)	 

		

		local roll = math.random(1, animTable[animName].totalWeight) 

		local origRoll = roll

		local idx = 1

		while (roll > animTable[animName][idx].weight) do

			roll = roll - animTable[animName][idx].weight

			idx = idx + 1

		end

--		print(animName .. " * " .. idx .. " [" .. origRoll .. "]")

		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then

			

			if (toolAnimTrack ~= nil) then

				toolAnimTrack:Stop()

				toolAnimTrack:Destroy()

				transitionTime = 0

			end

					

			-- load it to the humanoid; get AnimationTrack

			toolAnimTrack = humanoid:LoadAnimation(anim)

			if priority then

				toolAnimTrack.Priority = priority

			end

			 

			-- play the animation

			toolAnimTrack:Play(transitionTime)

			toolAnimName = animName

			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)

		end

end

function stopToolAnimations()

	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then

		currentToolAnimKeyframeHandler:disconnect()

	end

	toolAnimName = ""

	toolAnimInstance = nil

	if (toolAnimTrack ~= nil) then

		toolAnimTrack:Stop()

		toolAnimTrack:Destroy()

		toolAnimTrack = nil

	end

	return oldAnim

end

-------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------------

function onRunning(speed)

	if speed > 0.01 then

		playAnimation("walk", 0.1, Humanoid)

		if currentAnimInstance and currentAnimInstance.AnimationId == "http://www.roblox.com/asset/?id=180426354" then

			setAnimationSpeed(speed / 14.5)

		end

		pose = "Running"

	else

		if emoteNames[currentAnim] == nil then

			playAnimation("idle", 0.1, Humanoid)

			pose = "Standing"

		end

	end

end

function onDied()

	pose = "Dead"

end

function onJumping()

	playAnimation("jump", 0.1, Humanoid)

	jumpAnimTime = jumpAnimDuration

	pose = "Jumping"

end

function onClimbing(speed)

	playAnimation("climb", 0.1, Humanoid)

	setAnimationSpeed(speed / 12.0)

	pose = "Climbing"

end

function onGettingUp()

	pose = "GettingUp"

end

function onFreeFall()

	if (jumpAnimTime <= 0) then

		playAnimation("fall", fallTransitionTime, Humanoid)

	end

	pose = "FreeFall"

end

function onFallingDown()

	pose = "FallingDown"

end

function onSeated()

	pose = "Seated"

end

function onPlatformStanding()

	pose = "PlatformStanding"

end

function onSwimming(speed)

	if speed > 0 then

		pose = "Running"

	else

		pose = "Standing"

	end

end

function getTool()	

	for _, kid in ipairs(Figure:GetChildren()) do

		if kid.className == "Tool" then return kid end

	end

	return nil

end

function getToolAnim(tool)

	for _, c in ipairs(tool:GetChildren()) do

		if c.Name == "toolanim" and c.className == "StringValue" then

			return c

		end

	end

	return nil

end

function animateTool()

	

	if (toolAnim == "None") then

		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)

		return

	end

	if (toolAnim == "Slash") then

		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)

		return

	end

	if (toolAnim == "Lunge") then

		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)

		return

	end

end

function moveSit()

	RightShoulder.MaxVelocity = 0.15

	LeftShoulder.MaxVelocity = 0.15

	RightShoulder:SetDesiredAngle(3.14 /2)

	LeftShoulder:SetDesiredAngle(-3.14 /2)

	RightHip:SetDesiredAngle(3.14 /2)

	LeftHip:SetDesiredAngle(-3.14 /2)

end

local lastTick = 0

function move(time)

	local amplitude = 1

	local frequency = 1

  	local deltaTime = time - lastTick

  	lastTick = time

	local climbFudge = 0

	local setAngles = false

  	if (jumpAnimTime > 0) then

  		jumpAnimTime = jumpAnimTime - deltaTime

  	end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then

		playAnimation("fall", fallTransitionTime, Humanoid)

	elseif (pose == "Seated") then

		playAnimation("sit", 0.5, Humanoid)

		return

	elseif (pose == "Running") then

		playAnimation("walk", 0.1, Humanoid)

	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then

--		print("Wha " .. pose)

		stopAllAnimations()

		amplitude = 0.1

		frequency = 1

		setAngles = true

	end

	if (setAngles) then

		local desiredAngle = amplitude * math.sin(time * frequency)

		RightShoulder:SetDesiredAngle(desiredAngle + climbFudge)

		LeftShoulder:SetDesiredAngle(desiredAngle - climbFudge)

		RightHip:SetDesiredAngle(-desiredAngle)

		LeftHip:SetDesiredAngle(-desiredAngle)

	end

	-- Tool Animation handling

	local tool = getTool()

	if tool and tool:FindFirstChild("Handle") then

	

		local animStringValueObject = getToolAnim(tool)

		if animStringValueObject then

			toolAnim = animStringValueObject.Value

			-- message recieved, delete StringValue

			animStringValueObject.Parent = nil

			toolAnimTime = time + .3

		end

		if time > toolAnimTime then

			toolAnimTime = 0

			toolAnim = "None"

		end

		animateTool()		

	else

		stopToolAnimations()

		toolAnim = "None"

		toolAnimInstance = nil

		toolAnimTime = 0

	end

end

-- connect events

Humanoid.Died:connect(onDied)

Humanoid.Running:connect(onRunning)

Humanoid.Jumping:connect(onJumping)

Humanoid.Climbing:connect(onClimbing)

Humanoid.GettingUp:connect(onGettingUp)

Humanoid.FreeFalling:connect(onFreeFall)

Humanoid.FallingDown:connect(onFallingDown)

Humanoid.Seated:connect(onSeated)

Humanoid.PlatformStanding:connect(onPlatformStanding)

Humanoid.Swimming:connect(onSwimming)

-- setup emote chat hook

game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)

	local emote = ""

	if msg == "/e dance" then

		emote = dances[math.random(1, #dances)]

	elseif (string.sub(msg, 1, 3) == "/e ") then

		emote = string.sub(msg, 4)

	elseif (string.sub(msg, 1, 7) == "/emote ") then

		emote = string.sub(msg, 8)

	end

	

	if (pose == "Standing" and emoteNames[emote] ~= nil) then

		playAnimation(emote, 0.1, Humanoid)

	end

end)

-- main program

-- initialize to idle

playAnimation("idle", 0.1, Humanoid)

pose = "Standing"

while Figure.Parent ~= nil do

	local _, time = wait(0.1)

	move(time)

end

end)

Rightarm.Anchored = true

Torso.Anchored = true

Leftarm.Anchored = true

Rightleg.Anchored = true

Leftleg.Anchored = true

Character.Head.Anchored = true

for i=0,30 do

    wait()

    rig.HumanoidRootPart.RotVelocity = Vector3.new(0,0,0)

    rig.HumanoidRootPart.Velocity = Vector3.new(0,0,0)

end

game.Players.LocalPlayer.Character.Animate.Disabled = true

game:GetService("UserInputService").JumpRequest:connect(function(same)

if rig.Humanoid.FloorMaterial~=Enum.Material.Air then

rig.Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)

game.Players.LocalPlayer.Character.Dummy:FindFirstChildOfClass('Humanoid').Sit = false

end

end)

if Character.Humanoid.RigType == Enum.HumanoidRigType.R6 then

Character.HumanoidRootPart.RootJoint:Destroy()

elseif Character.Humanoid.RigType == Enum.HumanoidRigType.R15 then

Character.LowerTorso.Root:Destroy()

end

game.Players.LocalPlayer.Character.HumanoidRootPart.Anchored = true

Humanoid = game.Players.LocalPlayer.Character.Humanoid

game.RunService.RenderStepped:Connect(function()

 rig.Humanoid:Move(Character.Humanoid.MoveDirection, false)

 

local ActiveTracks = Humanoid:GetPlayingAnimationTracks()

for _,v in pairs(ActiveTracks) do

v:Stop()

end

end)

Rightarm.Anchored = false

Torso.Anchored = false

Leftarm.Anchored = false

Rightleg.Anchored = false

Leftleg.Anchored = false

Character.Head.Anchored = false

game.Workspace.CurrentCamera.CameraSubject = rig.Humanoid

--[[

local Humanoid1 = Character.Humanoid

local Humanoid2 = Character.Dummy.Humanoid

Humanoid2.Parent = Character

Humanoid1.Parent = Character.Dummy

]]--

game.Players.LocalPlayer.Character.Dummy.Head.face:Destroy()

local noclip = true char = game.Players.LocalPlayer.Character while true do if noclip == true then for _,v in pairs(char:children()) do pcall(function() if v.className == "Part" then v.CanCollide = false elseif v.ClassName == "Model" then v.Head.CanCollide = false end end) end end game:service("RunService").Stepped:wait() end

	rig.Humanoid:Move(game.Players.LocalPlayer.Character.Humanoid.MoveDirection, false)

spawn(function() while rig.Parent ~= nil do wait() end end)

end)

main:createbutton("Dev Uzi", function() -- add a button

game.Players.LocalPlayer.Character["RockAccessory"].Handle.SpecialMesh:Destroy()

HumanDied = false

local CountSCIFIMOVIELOL = 1

function SCIFIMOVIELOL(Part0,Part1,Position,Angle)

	local AlignPos = Instance.new('AlignPosition', Part1); AlignPos.Name = "AliP_"..CountSCIFIMOVIELOL

	AlignPos.ApplyAtCenterOfMass = true;

	AlignPos.MaxForce = 5772000--67752;

	AlignPos.MaxVelocity = math.huge/9e110;

	AlignPos.ReactionForceEnabled = false;

	AlignPos.Responsiveness = 200;

	AlignPos.RigidityEnabled = false;

	local AlignOri = Instance.new('AlignOrientation', Part1); AlignOri.Name = "AliO_"..CountSCIFIMOVIELOL

	AlignOri.MaxAngularVelocity = math.huge/9e110;

	AlignOri.MaxTorque = 5772000

	AlignOri.PrimaryAxisOnly = false;

	AlignOri.ReactionTorqueEnabled = false;

	AlignOri.Responsiveness = 200;

	AlignOri.RigidityEnabled = false;

	local AttachmentA=Instance.new('Attachment',Part1); AttachmentA.Name = "Ath_"..CountSCIFIMOVIELOL

	local AttachmentB=Instance.new('Attachment',Part0); AttachmentB.Name = "Ath_"..CountSCIFIMOVIELOL

	AttachmentA.Orientation = Angle or Vector3.new(0,0,0)

	AttachmentA.Position = Position or Vector3.new(0,0,0)

	AlignPos.Attachment1 = AttachmentA;

	AlignPos.Attachment0 = AttachmentB;

	AlignOri.Attachment1 = AttachmentA;

	AlignOri.Attachment0 = AttachmentB;

	CountSCIFIMOVIELOL = CountSCIFIMOVIELOL + 1

	return {AlignPos,AlignOri,AttachmentA,AttachmentB}

end

if _G.netted ~= true then

	_G.netted = true

	coroutine.wrap(function()

		game["Run Service"].RenderStepped:connect(function()

    settings().Physics.AllowSleep = false

    setsimulationradius(math.huge*math.huge,math.huge*math.huge)

end)

	end)()

end

game:FindFirstChildOfClass("Players").LocalPlayer["Character"].Archivable = true

local hatnameclone = {}

for _,v in next, game:FindFirstChildOfClass("Players").LocalPlayer["Character"]:GetChildren() do

	if v:IsA("Accessory") then

		if hatnameclone[v.Name] then

			if hatnameclone[v.Name] == "s" then

				hatnameclone[v.Name] = {}

			end

			table.insert(hatnameclone[v.Name],v)

		else

			hatnameclone[v.Name] = "s"

		end

	end

end

for _,v in pairs(hatnameclone) do

	if type(v) == "table" then

		local num = 1

		for _,w in pairs(v) do

			w.Name = w.Name..num

			num = num + 1

		end

	end

end

hatnameclone = nil

local DeadChar = game:FindFirstChildOfClass("Players").LocalPlayer.Character

local fldr = Instance.new("Folder",game:FindFirstChildOfClass("Players").LocalPlayer["Character"])

fldr.Name = "DMYF"

local CloneChar = DeadChar:Clone()

local ANIMATIONHERE

if CloneChar:FindFirstChild("Animate") then

	ANIMATIONHERE = CloneChar:FindFirstChild("Animate"):Clone()

	CloneChar:FindFirstChild("Animate"):Destroy()

end

if CloneChar:FindFirstChildOfClass("Folder") then CloneChar:FindFirstChildOfClass("Folder"):Destroy() end

if CloneChar.Torso:FindFirstChild("Neck") then

	local Clonessss = CloneChar.Torso:FindFirstChild("Neck"):Clone()

	Clonessss.Part0 = nil

	Clonessss.Part1 = DeadChar.Head

	Clonessss.Parent = DeadChar.Torso

end

CloneChar.Parent = fldr

CloneChar.HumanoidRootPart.CFrame = DeadChar.HumanoidRootPart.CFrame

CloneChar.Humanoid.BreakJointsOnDeath = false

CloneChar.Name = "non"

CloneChar.Humanoid.DisplayDistanceType = "None"

for _,v in next, DeadChar:GetChildren() do

	if v:IsA("Accessory") then

		local topacc = false

		if v.Handle:FindFirstChildOfClass("Weld") then v.Handle:FindFirstChildOfClass("Weld"):Destroy() end

		v.Handle.Massless = true

		v.Handle.CanCollide = false

		if v.Handle:FindFirstChildOfClass("Attachment") then

			local ath__ = v.Handle:FindFirstChildOfClass("Attachment")

			if ath__.Name == "HatAttachment" or ath__.Name == "HairAttachment" or ath__.Name == "FaceFrontAttachment" or ath__.Name == "FaceCenterAttachment" then

				topacc = ath__.Name

			end

		end

        local bv = Instance.new("BodyVelocity",v.Handle)

		bv.Velocity = Vector3.new(0,0,0)

		coroutine.wrap(function()

			if topacc then

				local allthings = SCIFIMOVIELOL(v.Handle,DeadChar.Torso,Vector3.new(0,1.5,0)+ (DeadChar.Head[topacc].Position + (v.Handle[topacc].Position*-1)),Vector3.new(0,0,0))

				local normaltop = allthings[1].Attachment1

				local alipos = allthings[1]

				local alirot = allthings[2]

				local p0 = v.Handle

				local p1 = DeadChar.Head

				alipos.Parent = CloneChar:FindFirstChild(v.Name).Handle

				alirot.Parent = CloneChar:FindFirstChild(v.Name).Handle

				while true do

					game:GetService("RunService").RenderStepped:wait()

					if HumanDied then break end

					coroutine.wrap(function()

						if alipos.Attachment1 == normaltop then

							p0.CFrame = p0.CFrame:lerp((((DeadChar.Torso.CFrame * CFrame.new(0,1.5,0)) * p1[topacc].CFrame) * p0[topacc].CFrame:inverse()),1)

						else

							v.Handle.CFrame = v.Handle.CFrame:lerp(alipos.Attachment1.Parent.CFrame * CFrame.new(alipos.Attachment1.Position) * CFrame.Angles(math.rad(alipos.Attachment1.Rotation.X),math.rad(alipos.Attachment1.Rotation.Y),math.rad(alipos.Attachment1.Rotation.Z)),1)

						end

					end)()

				end

			else

				SCIFIMOVIELOL(v.Handle,CloneChar[v.Name].Handle,Vector3.new(0,0,0),Vector3.new(0,0,0))

			end

		end)()

    end

end

local a = DeadChar.Torso

local b = DeadChar.HumanoidRootPart

local c = DeadChar.Humanoid

a.Parent = game:FindFirstChildOfClass("Workspace")

c.Parent = game:FindFirstChildOfClass("Workspace")

local told = a:Clone()

local told1 = c:Clone()

b["RootJoint"].Part0 = told

b["RootJoint"].Part1 = DeadChar.Head

a.Name = "torso"

a.Neck:Destroy()

c.Name = "Mizt Hub Best"

told.Parent = DeadChar

told1.Parent = DeadChar

DeadChar.PrimaryPart = told

told1.Health = 0

b:Destroy()

a.Parent = DeadChar

c.Parent = DeadChar

told:Destroy()

told1:Destroy()

a.Name = "Torso"

if CloneChar.Head:FindFirstChildOfClass("Decal") then CloneChar.Head:FindFirstChildOfClass("Decal").Transparency = 1 end

if DeadChar:FindFirstChild("Animate") then DeadChar:FindFirstChild("Animate"):Destroy() end

local Collider

function UnCollide()

    if HumanDied then Collider:Disconnect(); return end

    --[[for _,Parts in next, CloneChar:GetChildren() do

        if Parts:IsA("BasePart") then

            Parts.CanCollide = false 

        end 

    end]]

    for _,Parts in next, DeadChar:GetChildren() do

        if Parts:IsA("BasePart") then

        Parts.CanCollide = false

        end 

    end 

end

Collider = game:GetService("RunService").Stepped:Connect(UnCollide)

local resetBindable = Instance.new("BindableEvent")

resetBindable.Event:connect(function()

    game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)

	resetBindable:Destroy()

	HumanDied = true

    pcall(function()

		game:FindFirstChildOfClass("Players").LocalPlayer.Character = DeadChar

		DeadChar.Head:Destroy()

		DeadChar:FindFirstChildOfClass("Humanoid"):Destroy()

		game:FindFirstChildOfClass("Players").LocalPlayer.Character = CloneChar

		if DeadChar:FindFirstChildOfClass("Folder") then DeadChar:FindFirstChildOfClass("Folder"):Destroy() end

	end)

end)

game:GetService("StarterGui"):SetCore("ResetButtonCallback", resetBindable)

coroutine.wrap(function()

    while true do

        game:GetService("RunService").RenderStepped:wait()

        if not CloneChar or not CloneChar:FindFirstChild("Head") or not CloneChar:FindFirstChildOfClass("Humanoid") or CloneChar:FindFirstChildOfClass("Humanoid").Health <= 0 and not DeadChar or not DeadChar:FindFirstChild("Head") or not DeadChar:FindFirstChildOfClass("Humanoid") or DeadChar:FindFirstChildOfClass("Humanoid").Health <= 0 then 

            HumanDied = true

            pcall(function()

				game:FindFirstChildOfClass("Players").LocalPlayer.Character = DeadChar

				DeadChar.Head:Destroy()

				DeadChar:FindFirstChildOfClass("Humanoid"):Destroy()

				game:FindFirstChildOfClass("Players").LocalPlayer.Character = CloneChar

				if DeadChar:FindFirstChildOfClass("Folder") then DeadChar:FindFirstChildOfClass("Folder"):Destroy() end

			end)

            if resetBindable then

                game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)

                resetBindable:Destroy()

            end

            break

        end		

    end

end)()

SCIFIMOVIELOL(DeadChar["Head"],CloneChar["Head"])

SCIFIMOVIELOL(DeadChar["Torso"],CloneChar["Torso"])

SCIFIMOVIELOL(DeadChar["Left Arm"],CloneChar["Left Arm"])

SCIFIMOVIELOL(DeadChar["Right Arm"],CloneChar["Right Arm"])

SCIFIMOVIELOL(DeadChar["Left Leg"],CloneChar["Left Leg"])

SCIFIMOVIELOL(DeadChar["Right Leg"],CloneChar["Right Leg"])

for _,v in pairs(DeadChar:GetChildren()) do

	if v:IsA("BasePart") and v.Name ~= "Head" then

		--[[local bv = Instance.new("BodyVelocity",v)

		bv.Velocity = Vector3.new(0,0,0)

		coroutine.wrap(function()

			while true do

				game:GetService("RunService").RenderStepped:wait()

				if HumanDied then break end

				v.CFrame = CloneChar[v.Name].CFrame

			end

		end)()]]

	elseif v:IsA("BasePart") and v.Name == "Head" then

		local bv = Instance.new("BodyVelocity",v)

		bv.Velocity = Vector3.new(0,0,0)

		coroutine.wrap(function()

			while true do

				game:GetService("RunService").RenderStepped:wait()

				if HumanDied then break end

				v.CFrame = DeadChar.Torso.CFrame * CFrame.new(0,1.5,0)

			end

		end)()

	end

end

for _,BodyParts in next, CloneChar:GetDescendants() do

if BodyParts:IsA("BasePart") or BodyParts:IsA("Part") then

BodyParts.Transparency = 1 end end

game:GetService("RunService").RenderStepped:wait()

game:FindFirstChildOfClass("Players").LocalPlayer.Character = CloneChar

game:FindFirstChildOfClass("Workspace"):FindFirstChildOfClass("Camera").CameraSubject = CloneChar.Humanoid

for _,v in next, DeadChar:GetChildren() do

	if v:IsA("Accessory") then

		if v.Handle:FindFirstChildOfClass("Weld") then v.Handle:FindFirstChildOfClass("Weld"):Destroy() end

	end

end

----------------------------------------------------------------------------------------

function weld(parent,part1,part0,c0,c1)

local weld = Instance.new("Weld")

weld.Parent=parent

weld.Part1=part1

weld.Part0=part0

weld.C0=c0

weld.C1=c1

return weld

end

---------------------------------------------------------------------

local chr = game.Players.LocalPlayer.Character

local no = chr["METALXLIGHTSEER77Accessory"]

no.Handle:FindFirstChild("AccessoryWeld"):Remove()

local handleweld1 = no.Handle

handleweld1 = weld(handleweld1,chr["Right Arm"],handleweld1,CFrame.new(0, 0, 0), CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)))

------------------------------------------------------

local chr = game.Players.LocalPlayer.Character

local yes = chr["RockAccessory"]

yes.Handle:FindFirstChild("AccessoryWeld"):Remove()

local handleweld2 = yes.Handle

handleweld2 = weld(handleweld2,chr["HumanoidRootPart"],handleweld2,CFrame.new(0, 0, 0), CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(50), math.rad(10), math.rad(30)))

----------------------------------------------------------------------

Player = game:GetService("Players").LocalPlayer

PlayerGui = Player.PlayerGui

Cam = workspace.CurrentCamera

Backpack = Player.Backpack

Character = game.Players.LocalPlayer.Character

Humanoid = Character.Humanoid

Mouse = Player:GetMouse()

RootPart = Character.HumanoidRootPart

Torso = Character.Torso

Head = Character.Head

RightArm = Character["Right Arm"]

LeftArm = Character["Left Arm"]

RightLeg = Character["Right Leg"]

LeftLeg = Character["Left Leg"]

RootJoint = RootPart.RootJoint

Neck = Torso.Neck

RightShoulder = Torso["Right Shoulder"]

LeftShoulder = Torso["Left Shoulder"]

RightHip = Torso["Right Hip"]

LeftHip = Torso["Left Hip"]

Equipped = false

-------------------------------------------------------------------------

local kan= Instance.new("Sound", Character["Torso"])

kan.SoundId = "rbxassetid://1836012774"

kan.TimePosition = 0

kan.Looped = true

kan.Pitch = 1

kan.Volume = 1

kan:Play()

function unanchor()

	if UNANCHOR == true then

		g = CharacterA:GetChildren()

		for i = 1, #g do

			if g[i].ClassName == "Part" then

				g[i].Anchored = false

			end

		end

	end

end

IT = Instance.new

CF = CFrame.new

VT = Vector3.new

RAD = math.rad

C3 = Color3.new

UD2 = UDim2.new

HOLD = false

BRICKC = BrickColor.new

ANGLES = CFrame.Angles

EULER = CFrame.fromEulerAnglesXYZ

COS = math.cos

ACOS = math.acos

SIN = math.sin

ASIN = math.asin

ABS = math.abs

MRANDOM = math.random

FLOOR = math.floor

--//=================================\\

--|| 	      USEFUL VALUES

--\\=================================//

Animation_Speed = 2.5

Frame_Speed = 0.016666666666666666

local FORCERESET = false

Frame_Speed = 1 / 80 -- (1 / 60) OR (1 / 80)

local Speed = 25

local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))

local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))

local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))

local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))

local DAMAGEMULTIPLIER = 1

local ANIM = "Idle"

local ATTACK = false

local HOLD = false

local Rooted = false

local SINE = 0

local SIZE = 1

local UserInputService = game:GetService("UserInputService")

local KEYHOLD = false

local CHANGE = 2 / Animation_Speed

local WALKINGANIM = false

local VALUE1 = false

local VALUE2 = false

local ROBLOXIDLEANIMATION = IT("Animation")

ROBLOXIDLEANIMATION.Name = "Roblox Idle Animation"

ROBLOXIDLEANIMATION.AnimationId = "http://www.roblox.com/asset/?id=180435571"

local ANIMATOR = Humanoid.Animator

local ANIMATE = Character:FindFirstChild("Animate")

local UNANCHOR = true

function Swait(NUMBER)

	if NUMBER == 0 or NUMBER == nil then

		game:GetService("RunService").RenderStepped:wait()

	else

		for i = 1, NUMBER do

			game:GetService("RunService").RenderStepped:wait()

		end

	end

end

function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)

	return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)

end

function QuaternionFromCFrame(cf)

	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()

	local trace = m00 + m11 + m22

	if trace > 0 then 

		local s = math.sqrt(1 + trace)

		local recip = 0.5 / s

		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5

	else

		local i = 0

		if m11 > m00 then

			i = 1

		end

		if m22 > (i == 0 and m00 or m11) then

			i = 2

		end

		if i == 0 then

			local s = math.sqrt(m00 - m11 - m22 + 1)

			local recip = 0.5 / s

			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip

		elseif i == 1 then

			local s = math.sqrt(m11 - m22 - m00 + 1)

			local recip = 0.5 / s

			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip

		elseif i == 2 then

			local s = math.sqrt(m22 - m00 - m11 + 1)

			local recip = 0.5 / s return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip

		end

	end

end

 

function QuaternionToCFrame(px, py, pz, x, y, z, w)

	local xs, ys, zs = x + x, y + y, z + z

	local wx, wy, wz = w * xs, w * ys, w * zs

	local xx = x * xs

	local xy = x * ys

	local xz = x * zs

	local yy = y * ys

	local yz = y * zs

	local zz = z * zs

	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))

end

 

function QuaternionSlerp(a, b, t)

	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]

	local startInterp, finishInterp;

	if cosTheta >= 0.0001 then

		if (1 - cosTheta) > 0.0001 then

			local theta = ACOS(cosTheta)

			local invSinTheta = 1 / SIN(theta)

			startInterp = SIN((1 - t) * theta) * invSinTheta

			finishInterp = SIN(t * theta) * invSinTheta

		else

			startInterp = 1 - t

			finishInterp = t

		end

	else

		if (1 + cosTheta) > 0.0001 then

			local theta = ACOS(-cosTheta)

			local invSinTheta = 1 / SIN(theta)

			startInterp = SIN((t - 1) * theta) * invSinTheta

			finishInterp = SIN(t * theta) * invSinTheta

		else

			startInterp = t - 1

			finishInterp = t

		end

	end

	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp

end

function Clerp(a, b, t)

	local qa = {QuaternionFromCFrame(a)}

	local qb = {QuaternionFromCFrame(b)}

	local ax, ay, az = a.x, a.y, a.z

	local bx, by, bz = b.x, b.y, b.z

	local _t = 1 - t

	return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))

end

function turnto(position)

	RootPart.CFrame = CFrame.new(RootPart.CFrame.p, Vector3.new(position.X, RootPart.Position.Y, position.Z)) * CFrame.new(0, 0, 0)

end

--end

while true do

	Swait()

	if Character:FindFirstChildOfClass("Humanoid") == nil then

		Humanoid = IT("Humanoid",Character)

	end

	for _,v in next, Humanoid:GetPlayingAnimationTracks() do

	    v:Stop();

	end

--

function Shoot()

        ATTACK = true

        Humanoid.WalkSpeed = 1

        kan = Instance.new("Sound", Character)

        kan.Volume = 1

        kan.Looped = true

        kan.TimePosition = 0

        kan.PlaybackSpeed = 1

        kan.Pitch = 1

        kan.SoundId = "rbxassetid://2204318084"

        kan.Name = "bang"

        kan:Play()

        HOLD = true

        while HOLD == true do

        Swait()

            turnto(Mouse.hit.p)

            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 ,-.1+.1* COS(SINE / 14)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)

	     	RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.4,0.5,-0.5) * ANGLES(RAD(90), RAD(30), RAD(0))* RIGHTSHOULDERC0, 1/ Animation_Speed)

		    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5,0.5+.07* COS(SINE / 14),0) * ANGLES(RAD(0), RAD(0), RAD(-5))* LEFTSHOULDERC0, 1 / Animation_Speed)

			RightHip.C0 = Clerp(RightHip.C0, CF(0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(5)), 1 / Animation_Speed)

			LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(-5)), 1 / Animation_Speed)

			handleweld2.C0 = Clerp(handleweld2.C0, CF(0, 0, 0) * ANGLES(RAD(500 + 500 * ABS(SINE/14)), RAD(500 + 500 * ABS(SINE/14)), RAD(500 + 500 * ABS(SINE/14))), 1)

			yes.Handle.Position = Mouse.hit.p

			Swait()

			yes.Handle.Position = no.Handle.Position

			Swait()

			yes.Handle.Position = Mouse.hit.p

			Swait()

			yes.Handle.Position = no.Handle.Position

        wait()

            turnto(Mouse.hit.p)

            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 ,-.1+.1* COS(SINE / 14)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)

	     	RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.4,0.6,0) * ANGLES(RAD(90), RAD(30), RAD(0))* RIGHTSHOULDERC0, 1/ Animation_Speed)

		    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5,0.5+.07* COS(SINE / 14),0) * ANGLES(RAD(0), RAD(0), RAD(-5))* LEFTSHOULDERC0, 1 / Animation_Speed)

			RightHip.C0 = Clerp(RightHip.C0, CF(0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(5)), 1 / Animation_Speed)

			LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(-5)), 1 / Animation_Speed)

			handleweld2.C0 = Clerp(handleweld2.C0, CF(0, 0, 0) * ANGLES(RAD(500 + 500 * ABS(SINE/14)), RAD(500 + 500 * ABS(SINE/14)), RAD(500 + 500 * ABS(SINE/14))), 1)

			yes.Handle.Position = Mouse.hit.p

			Swait()

			yes.Handle.Position = no.Handle.Position

			Swait()

			yes.Handle.Position = Mouse.hit.p

			Swait()

			yes.Handle.Position = no.Handle.Position

        end

    Humanoid.WalkSpeed = 16

end

Mouse.Button1Down:connect(function()

    if ATTACK == false and HOLD == false then

        Shoot()

    end

end)

Mouse.Button1Up:connect(function()

    if ATTACK == true and HOLD == true then

        kan:Destroy()

        HOLD = false

        ATTACK = false

    end

end)

--	

local TORSOVELOCITY = (RootPart.Velocity * VT(1, 0, 1)).magnitude

local TORSOVERTICALVELOCITY = RootPart.Velocity.y

local NameClan = 0

local HITFLOOR = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 5, Character)

local WALKSPEEDVALUE = 6 / (Humanoid.WalkSpeed / 16)

	SINE = SINE + CHANGE

	if TORSOVERTICALVELOCITY > 1 and ATTACK == false and Equipped == false and HITFLOOR == nil then

		ANIM = "Jump"        

            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 ,-.1+.1* COS(SINE / 14)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.14 / Animation_Speed)

	     	RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.2,0.2+.1* COS(SINE / 14),0.2) * ANGLES(RAD(-40), RAD(-5), RAD(-40))* RIGHTSHOULDERC0, 0.55/ Animation_Speed)

		    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.2,0.2+.1* COS(SINE / 14),0.2) * ANGLES(RAD(-40), RAD(10), RAD(40))* LEFTSHOULDERC0, 0.55 / Animation_Speed)

			RightHip.C0 = Clerp(RightHip.C0, CF(0.5,-0.2,-0.2) * ANGLES(RAD(-20), RAD(0), RAD(5)), 1 / Animation_Speed)

			LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.5,-0.9-.05* COS(SINE / 14),0.5) * ANGLES(RAD(-10), RAD(0), RAD(-5)), 1 / Animation_Speed)

elseif TORSOVERTICALVELOCITY < -1 and ATTACK == false and Equipped == false and HITFLOOR == nil then

		ANIM = "Fall"

            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 ,-.1+.1* COS(SINE / 14)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.14 / Animation_Speed)

	     	RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.2,0.2+.1* COS(SINE / 14),0.2) * ANGLES(RAD(-40), RAD(-5), RAD(-40))* RIGHTSHOULDERC0, 0.55/ Animation_Speed)

		    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.2,0.2+.1* COS(SINE / 14),0.2) * ANGLES(RAD(-40), RAD(10), RAD(40))* LEFTSHOULDERC0, 0.55 / Animation_Speed)

			RightHip.C0 = Clerp(RightHip.C0, CF(0.5,-0.2,-0.2) * ANGLES(RAD(-20), RAD(0), RAD(5)), 0.75 / Animation_Speed)

			LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.5,-0.9-.05* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(-5)), 0.75 / Animation_Speed)

        elseif TORSOVELOCITY < 1 and ATTACK == false and Equipped == false and HITFLOOR ~= nil then

		ANIM = "Idle"

	

            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 ,-.1+.1* COS(SINE / 14)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.14 / Animation_Speed)

	     	RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.1,0.1+.07* COS(SINE / 14),-0.5) * ANGLES(RAD(70), RAD(20), RAD(-70))* RIGHTSHOULDERC0, 0.55/ Animation_Speed)

		    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.4,0.1+.07* COS(SINE / 14),-0.3) * ANGLES(RAD(40), RAD(0), RAD(-5))* LEFTSHOULDERC0, 0.55 / Animation_Speed)

			RightHip.C0 = Clerp(RightHip.C0, CF(0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(5)), 0.14 / Animation_Speed)

			LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(-5)), 0.14 / Animation_Speed)

			handleweld1.C0 = Clerp(handleweld1.C0, CF(1.4,-0.1,0) * ANGLES(RAD(-90), RAD(145), RAD(90)), 0.55 / Animation_Speed)

			handleweld2.C0 = Clerp(handleweld2.C0, CF(-1.4,100,0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.55 / Animation_Speed)

        elseif TORSOVELOCITY < 25 and ATTACK == false and HITFLOOR ~= nil then

		ANIM = "Walk"

            RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, -0.175 + 0.1 * COS(SINE / 3.5) + -SIN(SINE / 3.5) / 7) * ANGLES(RAD(9-2.5 * COS(SINE / 3.5)), RAD(0), RAD(0)), 0.15)

            RightHip.C0 = Clerp(RightHip.C0, CF(0.5, -0.925 - 0.5 * COS(SINE / 4) / 10, 0.5+0.5 * COS(SINE / 5) / 10) * ANGLES(RAD(-15 - 35 * COS(SINE / 7)) + -SIN(SINE / 7) / 2.5, RAD(0 - 2 * COS(SINE / 7)), RAD(0)) * ANGLES(RAD(0 + 2.5 * COS(SINE / 7)), RAD(0), RAD(0)), 0.55)

            LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.5, -0.925 + 0.5 * COS(SINE / 4) / 10, 0.5-0.5 * COS(SINE / 5) / 10) * ANGLES(RAD(-15 + 35 * COS(SINE / 7)) + SIN(SINE / 7) / 2.5, RAD(0 - 2 * COS(SINE / 7)), RAD(0)) * ANGLES(RAD(0 - 2.5 * COS(SINE / 7)), RAD(0), RAD(0)), 0.55)

            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5,0.4- .05 * COS(SINE / 3.5),0) * ANGLES(RAD(-40 + 5 * COS(SINE / 7)), RAD(0), RAD(10))* RIGHTSHOULDERC0, 0.55/ Animation_Speed)

		    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5,0.4 - .05 * COS(SINE / 3.5),0) * ANGLES(RAD(0 - 35 * COS(SINE / 7)), RAD(0), RAD(0))* LEFTSHOULDERC0, 0.55 / Animation_Speed)

            handleweld1.C0 = Clerp(handleweld1.C0, CF(1.4,-0.1,0) * ANGLES(RAD(-90), RAD(145), RAD(90)), 0.55 / Animation_Speed)

            handleweld2.C0 = Clerp(handleweld2.C0, CF(-1.4,100,0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.55 / Animation_Speed)

    end

end

unanchor()

end)

main:createbutton("Celestial Titan", function() -- add a button

--=[Network]=--

local NetworkAccess = coroutine.create(function()

settings().Physics.AllowSleep = false

while true do game:GetService("RunService").RenderStepped:Wait()

game:GetService("Players").LocalPlayer.ReplicationFocus = workspace

game:GetService("Players").LocalPlayer.MaximumSimulationRadius = math.pow(math.huge,math.huge)

sethiddenproperty(game:GetService("Players").LocalPlayer,"SimulationRadius",math.huge*math.huge) end end)

coroutine.resume(NetworkAccess)

local unanchoredparts = {}

local movers = {}

 local tog = true

 local move = false

local Player = game:GetService("Players").LocalPlayer

local Character = Player.Character

local mov = {};

local mov2 = {};

game.Players.LocalPlayer.Character.Head.Transparency = 1

game.Players.LocalPlayer.Character.Torso.Transparency = 1

game.Players.LocalPlayer.Character["Left Arm"].Transparency = 1

game.Players.LocalPlayer.Character["Right Arm"].Transparency = 1

game.Players.LocalPlayer.Character["Left Leg"].Transparency = 1

game.Players.LocalPlayer.Character["Right Leg"].Transparency = 1

loadstring(game:HttpGet("https://pastebin.com/raw/gapWmEYv",true))()

Character["Bang w bun"].Name = "bang1"

Character["Bang w bun"].Name = "bang2"

Character["Bang w bun"].Name = "bang3"

local Hats = {ra = Character:WaitForChild("bang1"),

t = Character:WaitForChild("Cyber Peacock Tail 2.0"),

la = Character:WaitForChild("bang2"),

rl = Character:WaitForChild("bang3"),

lr = Character:WaitForChild("BoyAnimeHair"),

hed = Character:WaitForChild("shattered sai "),

axe = Character:WaitForChild("CorruptLordSword")

}

Hats.hed.Handle.SpecialMesh:Destroy()

for i,v in next, Hats do

v.Handle.AccessoryWeld:Remove()

for _,mesh in next, v:GetDescendants() do

if mesh:IsA("Mesh") or mesh:IsA("SpecialMesh") then

mesh:Clone() 

end

end

end

game["Run Service"].RenderStepped:connect(function()

    settings().Physics.PhysicsEnvironmentalThrottle = Enum.EnviromentalPhysicsThrottle.Disabled

    settings().Physics.AllowSleep = false

    setsimulationradius(math.huge*math.huge,math.huge*math.huge)

end)

spawn(function()

while true do

settings().Physics.AllowSleep = false

game:GetService("Players").LocalPlayer.ReplicationFocus = workspace

sethiddenproperty(game.Players.LocalPlayer, "SimulationRadius", 1/0)

sethiddenproperty(game.Players.LocalPlayer, "MaximumSimulationRadius", 1/0)

setsimulationradius(1/0)

game:GetService("RunService").Heartbeat:wait()

end

end)

game["Run Service"].RenderStepped:connect(function()

    settings().Physics.AllowSleep = false

    setsimulationradius(math.huge*math.huge,math.huge*math.huge)

end)

local Network = coroutine.create(function()

while true do

game:GetService("RunService").Heartbeat:Wait()

settings().Physics.AllowSleep = false

sethiddenproperty(game.Players.LocalPlayer,"MaximumSimulationRadius",(7.0000001355554e+31)*7.0000001355554e+31)

sethiddenproperty(game.Players.LocalPlayer,"SimulationRadius",(7.0000001355554e+31)*7.0000001355554e+31)

end

end)

local NetworkAccess = coroutine.create(function()

settings().Physics.AllowSleep = false

while true do game:GetService("RunService").RenderStepped:Wait()

for _,Players in next, game:GetService("Players"):GetChildren() do

if Players ~= game:GetService("Players").LocalPlayer then

Players.MaximumSimulationRadius = 0.1 Players.SimulationRadius = 0 end end

coroutine.resume(NetworkAccess)

_G.sim = {}

local set = setsimulationradius or set_simulation_radius

getgenv().setsim = function(maxsimvalue, simvalue)

	set(simvalue, maxsimvalue)

	local s = pcall(function()

		local maxsim = game.Players.LocalPlayer.MaximumSimulationRadius

		local sim = game.Players.LocalPlayer.SimulationRadius

	end)

	if s then

		table.insert(_G.sim, {game.Players.LocalPlayer, "MaximumSimulationRadius", 1000})

		table.insert(_G.sim, {game.Players.LocalPlayer, "SimulationRadius", 1000})

	end

end

getgenv().setothersim = function(maxsimvalue, simvalue)

	local Players = game.Players:GetChildren()

	for i,v in pairs(Players) do

		if v ~= game.Players.LocalPlayer then

		    setscriptable(v, "MaximumSimulationRadius", true)

	        setscriptable(v, "SimulationRadius", true)

	        v.MaximumSimulationRadius = maxsimvalue

	        v.SimulationRadius = simvalue

			local s = pcall(function()

				local maxsim = v.MaximumSimulationRadius

				local sim = v.SimulationRadius

			end)

			if s then

				table.insert(_G.sim, {v, "MaximumSimulationRadius", 1000})

				table.insert(_G.sim, {v, "SimulationRadius", 1000})

			end

		end

	end

end

getgenv().findwithintable = function(o, p)

	for i, v in pairs(_G.sim) do

		if table.find(v, o) and table.find(v, p) then

			return v

		end

	end

	return nil

end

local mt = getrawmetatable(game)

setreadonly(mt, false)

old = mt.__index

mt.__index = newcclosure(function(o, p)

	local t = findwithintable(o, p)

	if t ~= nil then

		return t[3]

	end

	

	return old(o, p)

end)

local NetworkAccess = coroutine.create(function()

	Frame_Speed=1/60;ArtificialHB=Instance.new("BindableEvent",workspace)ArtificialHB.Name="ArtificialHB"workspace:WaitForChild("ArtificialHB")frame=Frame_Speed;tf=0;allowframeloss=false;tossremainder=false;lastframe=tick()workspace.ArtificialHB:Fire()game:GetService("RunService").Heartbeat:connect(function(a,b)tf=tf+a;if tf>=frame then if allowframeloss then script.ArtificialHB:Fire()lastframe=tick()else for c=1,math.floor(tf/frame)do workspace.ArtificialHB:Fire()end;lastframe=tick()end;if tossremainder then tf=0 else tf=tf-frame*math.floor(tf/frame)end end end)function swait(d)if d==0 or d==nil then ArtificialHB.Event:wait()else for c=1,d do ArtificialHB.Event:wait(d)end end end

	local a=game.Players:GetChildren()for b,c in pairs(a)do if c~=game.Players.LocalPlayer then setscriptable(c,"MaximumSimulationRadius",true)setscriptable(c,"SimulationRadius",true)c.MaximumSimulationRadius=0.1;c.SimulationRadius=0 end end

	local set = setsimulationradius or set_simulation_radius

    setsim(math.huge, math.huge)

    setothersim(0.1, 0)

	spawn(function()

		while true do

			settings().Physics.AllowSleep = false

			game:GetService("Players").LocalPlayer.ReplicationFocus = workspace

			swait()

		end

	end)

end)

coroutine.resume(NetworkAccess)

spawn(function()

while true do

settings().Physics.AllowSleep = false

game:GetService("Players").LocalPlayer.ReplicationFocus = workspace

sethiddenproperty(game.Players.LocalPlayer, "SimulationRadius", 0/0)

sethiddenproperty(game.Players.LocalPlayer, "MaximumSimulationRadius", 0/0)

setsimulationradius(0/0)

game:GetService("RunService").Heartbeat:wait()

end end) end end)

function ftp(str)

    local pt = {};

    if str ~= 'me' and str ~= 'random' then

        for i, v in pairs(game.Players:GetPlayers()) do

            if v.Name:lower():find(str:lower()) then

                table.insert(pt, v);

            end

        end

    elseif str == 'me' then

        table.insert(pt, plr);

	elseif str == 'random' then

		table.insert(pt, game.Players:GetPlayers()[math.random(1, #game.Players:GetPlayers())]);

    end

    return pt;

end

Character.Head.Transparency = 1

Character.Head.face:Clone()

Character.Torso.Transparency = 1

Character["Right Arm"].Transparency = 1

Character["Left Arm"].Transparency = 1

Character["Right Leg"].Transparency = 1

Character["Left Leg"].Transparency = 1

local function align(i,v)

local att0 = Instance.new("Attachment", i)

att0.Position = Vector3.new(0,0,0)

local att1 = Instance.new("Attachment", v)

att1.Position = Vector3.new(0,0,0)

local AP = Instance.new("AlignPosition", i)

AP.Attachment0 = att0

AP.Attachment1 = att1

AP.RigidityEnabled = false

AP.ReactionForceEnabled = false

AP.ApplyAtCenterOfMass = true

AP.MaxForce = 9999999999999999999999999999999999999

AP.MaxVelocity = math.huge

AP.Responsiveness = 9999999999999999999999999999999999999

local AO = Instance.new("AlignOrientation", i)

AO.Attachment0 = att0

AO.Attachment1 = att1

AO.ReactionTorqueEnabled = false

AO.PrimaryAxisOnly = false

AO.MaxTorque = 9999999999999999999999999999999999999

AO.MaxAngularVelocity = math.huge

AO.Responsiveness = 9999999999999999999999999999999999999

end

Hats.ra.Handle.SpecialMesh:Destroy()

Hats.la.Handle.SpecialMesh:Destroy()

Hats.rl.Handle.SpecialMesh:Destroy()

Hats.t.Handle.SpecialMesh:Destroy()

Hats.lr.Handle.Mesh:Destroy()

align(Hats.ra.Handle, Character["Right Arm"])

align(Hats.la.Handle, Character["Left Arm"])

align(Hats.t.Handle, Character.Torso)

Hats.t.Handle.Attachment.Rotation = Vector3.new(-88, -180, 180)

align(Hats.hed.Handle, Character.Head)

align(Hats.lr.Handle, Character["Left Leg"])

align(Hat
